Last login: Fri Jun 22 13:07:37 on ttys000
Omars-Mac-Pro:RCN omarmrivas$ pwd
/Users/omarmrivas/Projects/GP.libs/RCN
Omars-Mac-Pro:RCN omarmrivas$ ls
Algebra.fs       DataTypes.fs     Program.fs       bin
Approximation.fs Graph.fs         RCN.fsproj       obj
Omars-Mac-Pro:RCN omarmrivas$ dotnet run --configuration Release
/Users/omarmrivas/Projects/GP.libs/RCN/RCN.fsproj : warning NU1603: FsPickler 4.0.1 depends on FSharp.Compiler.Tools (>= 0.0.0) but FSharp.Compiler.Tools 0.0.0 was not found. An approximate best match of FSharp.Compiler.Tools 3.1.2.2 was resolved.
/Users/omarmrivas/Projects/GP.libs/RCN/RCN.fsproj : warning NU1701: Package 'FsPickler 4.0.1' was restored using '.NETFramework,Version=v4.6.1' instead of the project target framework '.NETCoreApp,Version=v2.0'. This package may not be fully compatible with your project.
/Users/omarmrivas/Projects/GP.libs/RCN/RCN.fsproj : warning NU1603: FsPickler 4.0.1 depends on FSharp.Compiler.Tools (>= 0.0.0) but FSharp.Compiler.Tools 0.0.0 was not found. An approximate best match of FSharp.Compiler.Tools 3.1.2.2 was resolved.
/Users/omarmrivas/Projects/GP.libs/RCN/RCN.fsproj : warning NU1701: Package 'FsPickler 4.0.1' was restored using '.NETFramework,Version=v4.6.1' instead of the project target framework '.NETCoreApp,Version=v2.0'. This package may not be fully compatible with your project.
Var: "Mx", counts: [|(47, 3); (51, 219)|]
Var: "My", counts: [|(47, 3); (51, 219)|]
Var: "Mz", counts: [|(47, 3); (51, 219)|]
Var: "Gx", counts: [|(43, 1); (44, 4); (45, 6); (46, 2); (47, 56); (49, 600); (50, 14); (51, 7814)|]
Var: "Gy", counts: [|(43, 1); (44, 4); (45, 6); (46, 2); (47, 56); (49, 600); (50, 14); (51, 7814)|]
Using GP to obtain Graph (size = 4) with minimal RCN.
scheme: fun Mx My Mz Gx Gy -> let Mx = Mx in let My = My in let Mz = Mz in let Gx = Gx in let Gy = Gy in let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Mx (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x (ax - 1) ay az agraph) (y (ax - 1) ay az agraph) (z (ax - 1) ay az agraph)) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else My (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x ax (ay - 1) az agraph) (y ax (ay - 1) az agraph) (z ax (ay - 1) az agraph)) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Mz (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x ax ay (az - 1) agraph) (y ax ay (az - 1) agraph) (z ax ay (az - 1) agraph)) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> List.map (fun i -> let xi = x ax ay az (agraph - 1) i in let yi = y ax ay az (agraph - 1) i in let zi = z ax ay az (agraph - 1) i in let cx = Gx i Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det xi yi zi in let cy = Gy i Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det xi yi zi in (cx, cy)) |> let state = Some(Graph.empty_graph) in fun list -> List.fold Graph.add_vertex state list) in fun () -> Program.fitness 0 (graph 6 6 6 6)

             term_size: 7

             population_size: 1000

             generations: 10000

             bests: 20

             mutation_prob: 0.100

             timeout: 120.0 sec

             load_file: <null>

             save_file: pool4.save

Building initial population...
100.000%
Graph (size = 4)
Generation: 1
Solution: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else y (ax - 1) ay az agraph (n - 1)) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else z ax (ay - 1) az agraph (n - 1)) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.pi Approximation.pi Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Approximation.exp (Approximation.to_base i), Algebra.dot (Algebra.v_sub (x ax ay az (agraph - 1) i) (y ax ay az (agraph - 1) i)) (z ax ay az (agraph - 1) i))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 0 (graph 6 6 6 6)
Using GP to obtain Graph (size = 5) with minimal RCN.
scheme: fun Mx My Mz Gx Gy -> let Mx = Mx in let My = My in let Mz = Mz in let Gx = Gx in let Gy = Gy in let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Mx (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x (ax - 1) ay az agraph) (y (ax - 1) ay az agraph) (z (ax - 1) ay az agraph)) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else My (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x ax (ay - 1) az agraph) (y ax (ay - 1) az agraph) (z ax (ay - 1) az agraph)) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Mz (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x ax ay (az - 1) agraph) (y ax ay (az - 1) agraph) (z ax ay (az - 1) agraph)) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> List.map (fun i -> let xi = x ax ay az (agraph - 1) i in let yi = y ax ay az (agraph - 1) i in let zi = z ax ay az (agraph - 1) i in let cx = Gx i Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det xi yi zi in let cy = Gy i Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det xi yi zi in (cx, cy)) |> let state = Some(Graph.empty_graph) in fun list -> List.fold Graph.add_vertex state list) in fun () -> Program.fitness 1 (graph 7 7 7 7)

             term_size: 7

             population_size: 1000

             generations: 10000

             bests: 20

             mutation_prob: 0.100

             timeout: 120.0 sec

             load_file: Some "pool4.save"

             save_file: pool5.save

Building initial population...
Deserializing GP pool
Graph (size = 5)
Generation: 1
Best individual: 1.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else y (ax - 1) ay az agraph (n - 1)) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else z ax (ay - 1) az agraph (n - 1)) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.pi Approximation.pi Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Approximation.exp (Approximation.to_base i), Algebra.dot (Algebra.v_sub (x ax ay az (agraph - 1) i) (y ax ay az (agraph - 1) i)) (z ax ay az (agraph - 1) i))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 1 (graph 7 7 7 7)
100.000%

Elapsed Time: 172 sec
Graph (size = 5)
Generation: 2
Best individual: 1.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else y (ax - 1) ay az agraph (n - 1)) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else z ax (ay - 1) az agraph (n - 1)) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.pi Approximation.pi Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Approximation.exp (Approximation.to_base i), Algebra.dot (Algebra.v_sub (x ax ay az (agraph - 1) i) (y ax ay az (agraph - 1) i)) (z ax ay az (agraph - 1) i))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 1 (graph 7 7 7 7)
100.000%

Elapsed Time: 184 sec
Graph (size = 5)
Generation: 3
Best individual: 1.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else y (ax - 1) ay az agraph (n - 1)) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else z ax (ay - 1) az agraph (n - 1)) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.pi Approximation.pi Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Approximation.exp (Approximation.to_base i), Algebra.dot (Algebra.v_sub (x ax ay az (agraph - 1) i) (y ax ay az (agraph - 1) i)) (z ax ay az (agraph - 1) i))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 1 (graph 7 7 7 7)
100.000%

Elapsed Time: 168 sec
Graph (size = 5)
Generation: 4
Best individual: 1.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else y (ax - 1) ay az agraph (n - 1)) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else z ax (ay - 1) az agraph (n - 1)) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.pi Approximation.pi Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Approximation.exp (Approximation.to_base i), Algebra.dot (Algebra.v_sub (x ax ay az (agraph - 1) i) (y ax ay az (agraph - 1) i)) (z ax ay az (agraph - 1) i))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 1 (graph 7 7 7 7)
100.000%

Elapsed Time: 158 sec
Graph (size = 5)
Generation: 5
Best individual: 1.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else y (ax - 1) ay az agraph (n - 1)) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else z ax (ay - 1) az agraph (n - 1)) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.pi Approximation.pi Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Approximation.exp (Approximation.to_base i), Algebra.dot (Algebra.v_sub (x ax ay az (agraph - 1) i) (y ax ay az (agraph - 1) i)) (z ax ay az (agraph - 1) i))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 1 (graph 7 7 7 7)
100.000%

Elapsed Time: 157 sec
Graph (size = 5)
Generation: 6
Best individual: 1.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else y (ax - 1) ay az agraph (n - 1)) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else z ax (ay - 1) az agraph (n - 1)) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.pi Approximation.pi Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Approximation.exp (Approximation.to_base i), Algebra.dot (Algebra.v_sub (x ax ay az (agraph - 1) i) (y ax ay az (agraph - 1) i)) (z ax ay az (agraph - 1) i))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 1 (graph 7 7 7 7)
100.000%

Elapsed Time: 153 sec
Graph (size = 5)
Generation: 7
Best individual: 1.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else y (ax - 1) ay az agraph (n - 1)) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else z ax (ay - 1) az agraph (n - 1)) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.pi Approximation.pi Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Approximation.exp (Approximation.to_base i), Algebra.dot (Algebra.v_sub (x ax ay az (agraph - 1) i) (y ax ay az (agraph - 1) i)) (z ax ay az (agraph - 1) i))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 1 (graph 7 7 7 7)
100.000%

Elapsed Time: 158 sec
Graph (size = 5)
Generation: 8
Best individual: 1.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else y (ax - 1) ay az agraph (n - 1)) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else z ax (ay - 1) az agraph (n - 1)) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.pi Approximation.pi Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Approximation.exp (Approximation.to_base i), Algebra.dot (Algebra.v_sub (x ax ay az (agraph - 1) i) (y ax ay az (agraph - 1) i)) (z ax ay az (agraph - 1) i))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 1 (graph 7 7 7 7)
100.000%

Elapsed Time: 153 sec
Graph (size = 5)
Generation: 9
Best individual: 1.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else y (ax - 1) ay az agraph (n - 1)) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else z ax (ay - 1) az agraph (n - 1)) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.pi Approximation.pi Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Approximation.exp (Approximation.to_base i), Algebra.dot (Algebra.v_sub (x ax ay az (agraph - 1) i) (y ax ay az (agraph - 1) i)) (z ax ay az (agraph - 1) i))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 1 (graph 7 7 7 7)
100.000%

Elapsed Time: 154 sec
Graph (size = 5)
Generation: 10
Best individual: 1.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else y (ax - 1) ay az agraph (n - 1)) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else z ax (ay - 1) az agraph (n - 1)) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.pi Approximation.pi Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Approximation.exp (Approximation.to_base i), Algebra.dot (Algebra.v_sub (x ax ay az (agraph - 1) i) (y ax ay az (agraph - 1) i)) (z ax ay az (agraph - 1) i))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 1 (graph 7 7 7 7)
100.000%

Elapsed Time: 155 sec
Graph (size = 5)
Generation: 11
Best individual: 1.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else y (ax - 1) ay az agraph (n - 1)) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else z ax (ay - 1) az agraph (n - 1)) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.pi Approximation.pi Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Approximation.exp (Approximation.to_base i), Algebra.dot (Algebra.v_sub (x ax ay az (agraph - 1) i) (y ax ay az (agraph - 1) i)) (z ax ay az (agraph - 1) i))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 1 (graph 7 7 7 7)
100.000%

Elapsed Time: 144 sec
Graph (size = 5)
Generation: 12
Best individual: 1.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else y (ax - 1) ay az agraph (n - 1)) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else z ax (ay - 1) az agraph (n - 1)) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.pi Approximation.pi Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Approximation.exp (Approximation.to_base i), Algebra.dot (Algebra.v_sub (x ax ay az (agraph - 1) i) (y ax ay az (agraph - 1) i)) (z ax ay az (agraph - 1) i))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 1 (graph 7 7 7 7)
100.000%

Elapsed Time: 157 sec
Graph (size = 5)
Generation: 13
Best individual: 1.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else y (ax - 1) ay az agraph (n - 1)) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else z ax (ay - 1) az agraph (n - 1)) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.pi Approximation.pi Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Approximation.exp (Approximation.to_base i), Algebra.dot (Algebra.v_sub (x ax ay az (agraph - 1) i) (y ax ay az (agraph - 1) i)) (z ax ay az (agraph - 1) i))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 1 (graph 7 7 7 7)
100.000%

Elapsed Time: 159 sec
Graph (size = 5)
Generation: 14
Best individual: 1.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else y (ax - 1) ay az agraph (n - 1)) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else z ax (ay - 1) az agraph (n - 1)) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.pi Approximation.pi Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Approximation.exp (Approximation.to_base i), Algebra.dot (Algebra.v_sub (x ax ay az (agraph - 1) i) (y ax ay az (agraph - 1) i)) (z ax ay az (agraph - 1) i))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 1 (graph 7 7 7 7)
100.000%

Elapsed Time: 162 sec
Graph (size = 5)
Generation: 15
Best individual: 1.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else y (ax - 1) ay az agraph (n - 1)) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else z ax (ay - 1) az agraph (n - 1)) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.pi Approximation.pi Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Approximation.exp (Approximation.to_base i), Algebra.dot (Algebra.v_sub (x ax ay az (agraph - 1) i) (y ax ay az (agraph - 1) i)) (z ax ay az (agraph - 1) i))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 1 (graph 7 7 7 7)
100.000%

Elapsed Time: 164 sec
Graph (size = 5)
Generation: 16
Solution: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.zero Approximation.zero) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.pi Approximation.e Approximation.pi) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.pi Approximation.pi Approximation.pi) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div Approximation.e (Approximation.sin (Approximation.to_base i)), Algebra.sub (Approximation.exp (Approximation.sin (Approximation.exp (Approximation.to_base i)))) Approximation.one)) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 1 (graph 7 7 7 7)
Using GP to obtain Graph (size = 6) with minimal RCN.
scheme: fun Mx My Mz Gx Gy -> let Mx = Mx in let My = My in let Mz = Mz in let Gx = Gx in let Gy = Gy in let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Mx (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x (ax - 1) ay az agraph) (y (ax - 1) ay az agraph) (z (ax - 1) ay az agraph)) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else My (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x ax (ay - 1) az agraph) (y ax (ay - 1) az agraph) (z ax (ay - 1) az agraph)) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Mz (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x ax ay (az - 1) agraph) (y ax ay (az - 1) agraph) (z ax ay (az - 1) agraph)) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> List.map (fun i -> let xi = x ax ay az (agraph - 1) i in let yi = y ax ay az (agraph - 1) i in let zi = z ax ay az (agraph - 1) i in let cx = Gx i Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det xi yi zi in let cy = Gy i Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det xi yi zi in (cx, cy)) |> let state = Some(Graph.empty_graph) in fun list -> List.fold Graph.add_vertex state list) in fun () -> Program.fitness 2 (graph 8 8 8 8)

             term_size: 7

             population_size: 1000

             generations: 10000

             bests: 20

             mutation_prob: 0.100

             timeout: 120.0 sec

             load_file: Some "pool5.save"

             save_file: pool6.save

Building initial population...
Deserializing GP pool
Graph (size = 6)
Generation: 1
Best individual: 16.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.zero Approximation.zero) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.pi Approximation.e Approximation.pi) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.pi Approximation.pi Approximation.pi) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div Approximation.e (Approximation.sin (Approximation.to_base i)), Algebra.sub (Approximation.exp (Approximation.sin (Approximation.exp (Approximation.to_base i)))) Approximation.one)) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 2 (graph 8 8 8 8)
100.000%

Elapsed Time: 147 sec
Graph (size = 6)
Generation: 2
Best individual: 100.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.zero Approximation.zero) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.pi Approximation.e Approximation.pi) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.one Approximation.e Approximation.one) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div Approximation.e (Approximation.sin (Approximation.to_base i)), Algebra.sub (Approximation.exp (Approximation.sin (Approximation.exp (Approximation.to_base i)))) Approximation.one)) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 2 (graph 8 8 8 8)
100.000%

Elapsed Time: 150 sec
Graph (size = 6)
Generation: 3
Best individual: 196.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.zero Approximation.zero) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.three Approximation.one) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.pi Approximation.pi Approximation.pi) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div Approximation.e (Approximation.sin (Approximation.to_base i)), Algebra.sub (Approximation.exp (Approximation.cosh (Approximation.to_base i))) Approximation.one)) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 2 (graph 8 8 8 8)
100.000%

Elapsed Time: 164 sec
Graph (size = 6)
Generation: 4
Best individual: 196.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.zero Approximation.zero) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.three Approximation.one) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.pi Approximation.pi Approximation.pi) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div Approximation.e (Approximation.sin (Approximation.to_base i)), Algebra.sub (Approximation.exp (Approximation.cosh (Approximation.to_base i))) Approximation.one)) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 2 (graph 8 8 8 8)
100.000%

Elapsed Time: 148 sec
Graph (size = 6)
Generation: 5
Best individual: 196.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.zero Approximation.zero) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.three Approximation.one) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.pi Approximation.pi Approximation.pi) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div Approximation.e (Approximation.sin (Approximation.to_base i)), Algebra.sub (Approximation.exp (Approximation.cosh (Approximation.to_base i))) Approximation.one)) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 2 (graph 8 8 8 8)
100.000%

Elapsed Time: 163 sec
Graph (size = 6)
Generation: 6
Solution: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.zero Approximation.zero Approximation.zero) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.e Approximation.three Approximation.one) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.two Approximation.pi Approximation.pi) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.add Approximation.one (Approximation.cos (Approximation.to_base i)), Algebra.sub (Approximation.exp (Approximation.mpow (Approximation.log (Approximation.cosh (Approximation.log (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i)))) Approximation.one)) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 2 (graph 8 8 8 8)
Using GP to obtain Graph (size = 7) with minimal RCN.
scheme: fun Mx My Mz Gx Gy -> let Mx = Mx in let My = My in let Mz = Mz in let Gx = Gx in let Gy = Gy in let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Mx (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x (ax - 1) ay az agraph) (y (ax - 1) ay az agraph) (z (ax - 1) ay az agraph)) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else My (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x ax (ay - 1) az agraph) (y ax (ay - 1) az agraph) (z ax (ay - 1) az agraph)) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Mz (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x ax ay (az - 1) agraph) (y ax ay (az - 1) agraph) (z ax ay (az - 1) agraph)) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> List.map (fun i -> let xi = x ax ay az (agraph - 1) i in let yi = y ax ay az (agraph - 1) i in let zi = z ax ay az (agraph - 1) i in let cx = Gx i Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det xi yi zi in let cy = Gy i Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det xi yi zi in (cx, cy)) |> let state = Some(Graph.empty_graph) in fun list -> List.fold Graph.add_vertex state list) in fun () -> Program.fitness 3 (graph 9 9 9 9)

             term_size: 7

             population_size: 1000

             generations: 10000

             bests: 20

             mutation_prob: 0.100

             timeout: 120.1 sec

             load_file: Some "pool6.save"

             save_file: pool7.save

Building initial population...
Deserializing GP pool
Graph (size = 7)
Generation: 1
Best individual: 225.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.zero Approximation.zero) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.pi Approximation.e Approximation.pi) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.one Approximation.one Approximation.one) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div Approximation.e (Approximation.sin (Approximation.to_base i)), Algebra.sub (Approximation.exp (Algebra.add (Approximation.cosh (Approximation.sin (Approximation.cosh (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i)))) Approximation.one)) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 3 (graph 9 9 9 9)
100.000%

Elapsed Time: 159 sec
Graph (size = 7)
Generation: 2
Best individual: 1024.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.zero Approximation.pi Approximation.three) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.zero Approximation.pi Approximation.e) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.three Approximation.one Approximation.three) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div Approximation.e (Algebra.div (Approximation.mpow Approximation.three (Approximation.msqrt (Approximation.to_base i))) (Approximation.to_base i)), Algebra.mul (Approximation.cosh (Approximation.sinh (Approximation.to_base i))) Approximation.two)) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 3 (graph 9 9 9 9)
100.000%

Elapsed Time: 149 sec
Graph (size = 7)
Generation: 3
Best individual: 1156.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else y (ax - 1) ay az agraph (n - 1)) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.three Approximation.one) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.e Approximation.zero Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.sub Approximation.pi (Approximation.sinh (Approximation.to_base i)), Algebra.sub (Approximation.exp (Approximation.cosh (Approximation.to_base i))) Approximation.one)) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 3 (graph 9 9 9 9)
100.000%

Elapsed Time: 150 sec
Graph (size = 7)
Generation: 4
Best individual: 1225.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.pi Approximation.one) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.three Approximation.one) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.one Approximation.one Approximation.one) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Approximation.mpow Approximation.two (Approximation.exp (Approximation.to_base i))) (Approximation.sin (Approximation.to_base i)), Algebra.sub (Approximation.exp (Approximation.cosh (Approximation.to_base i))) Approximation.one)) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 3 (graph 9 9 9 9)
100.000%

Elapsed Time: 152 sec
Graph (size = 7)
Generation: 5
Best individual: 1225.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.pi Approximation.one) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.three Approximation.one) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.one Approximation.one Approximation.one) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Approximation.mpow Approximation.two (Approximation.exp (Approximation.to_base i))) (Approximation.sin (Approximation.to_base i)), Algebra.sub (Approximation.exp (Approximation.cosh (Approximation.to_base i))) Approximation.one)) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 3 (graph 9 9 9 9)
100.000%

Elapsed Time: 159 sec
Graph (size = 7)
Generation: 6
Solution: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.three Approximation.pi) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.zero Approximation.two Approximation.zero) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else y ax ay (az - 1) agraph (n - 1)) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Approximation.mpow Approximation.three (Approximation.sinh (Approximation.to_base i))) (Approximation.sin (Approximation.to_base i)), Approximation.mpow (Approximation.sin (Approximation.sinh (Approximation.to_base i))) Approximation.two)) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 3 (graph 9 9 9 9)
Using GP to obtain Graph (size = 8) with minimal RCN.
scheme: fun Mx My Mz Gx Gy -> let Mx = Mx in let My = My in let Mz = Mz in let Gx = Gx in let Gy = Gy in let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Mx (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x (ax - 1) ay az agraph) (y (ax - 1) ay az agraph) (z (ax - 1) ay az agraph)) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else My (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x ax (ay - 1) az agraph) (y ax (ay - 1) az agraph) (z ax (ay - 1) az agraph)) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Mz (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x ax ay (az - 1) agraph) (y ax ay (az - 1) agraph) (z ax ay (az - 1) agraph)) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> List.map (fun i -> let xi = x ax ay az (agraph - 1) i in let yi = y ax ay az (agraph - 1) i in let zi = z ax ay az (agraph - 1) i in let cx = Gx i Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det xi yi zi in let cy = Gy i Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det xi yi zi in (cx, cy)) |> let state = Some(Graph.empty_graph) in fun list -> List.fold Graph.add_vertex state list) in fun () -> Program.fitness 4 (graph 10 10 10 10)

             term_size: 7

             population_size: 1000

             generations: 10000

             bests: 20

             mutation_prob: 0.100

             timeout: 120.1 sec

             load_file: Some "pool7.save"

             save_file: pool8.save

Building initial population...
Deserializing GP pool
Graph (size = 8)
Generation: 1
Best individual: 1225.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.pi Approximation.one) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.three Approximation.one) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.one Approximation.one Approximation.one) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Approximation.mpow Approximation.two (Approximation.exp (Approximation.to_base i))) (Approximation.sin (Approximation.to_base i)), Algebra.sub (Approximation.exp (Approximation.cosh (Approximation.to_base i))) Approximation.one)) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 4 (graph 10 10 10 10)
100.000%

Elapsed Time: 150 sec
Graph (size = 8)
Generation: 2
Best individual: 4761.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.pi Approximation.three Approximation.three) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.zero Approximation.two Approximation.two) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.three Approximation.three Approximation.three) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Approximation.mpow Approximation.three (Approximation.sinh (Approximation.to_base i))) (Approximation.sin (Approximation.to_base i)), Approximation.mpow (Approximation.sinh (Approximation.msqrt (Approximation.to_base i))) Approximation.pi)) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 4 (graph 10 10 10 10)
100.000%

Elapsed Time: 149 sec
Graph (size = 8)
Generation: 3
Solution: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.two Approximation.two) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.e Approximation.three) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.pi Approximation.one Approximation.three) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div Approximation.e (Approximation.sin (Algebra.div (Algebra.sub Approximation.one (Approximation.sin (Approximation.to_base i))) (Approximation.cosh (Approximation.to_base i)))), Algebra.sub (Approximation.exp (Approximation.cosh (Approximation.to_base i))) Approximation.one)) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 4 (graph 10 10 10 10)
Using GP to obtain Graph (size = 9) with minimal RCN.
scheme: fun Mx My Mz Gx Gy -> let Mx = Mx in let My = My in let Mz = Mz in let Gx = Gx in let Gy = Gy in let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Mx (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x (ax - 1) ay az agraph) (y (ax - 1) ay az agraph) (z (ax - 1) ay az agraph)) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else My (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x ax (ay - 1) az agraph) (y ax (ay - 1) az agraph) (z ax (ay - 1) az agraph)) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Mz (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x ax ay (az - 1) agraph) (y ax ay (az - 1) agraph) (z ax ay (az - 1) agraph)) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> List.map (fun i -> let xi = x ax ay az (agraph - 1) i in let yi = y ax ay az (agraph - 1) i in let zi = z ax ay az (agraph - 1) i in let cx = Gx i Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det xi yi zi in let cy = Gy i Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det xi yi zi in (cx, cy)) |> let state = Some(Graph.empty_graph) in fun list -> List.fold Graph.add_vertex state list) in fun () -> Program.fitness 5 (graph 11 11 11 11)

             term_size: 7

             population_size: 1000

             generations: 10000

             bests: 20

             mutation_prob: 0.100

             timeout: 120.1 sec

             load_file: Some "pool8.save"

             save_file: pool9.save

Building initial population...
Deserializing GP pool
Graph (size = 9)
Generation: 1
Best individual: 4761.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.pi Approximation.three Approximation.three) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.zero Approximation.two Approximation.two) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.three Approximation.three Approximation.three) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Approximation.mpow Approximation.three (Approximation.sinh (Approximation.to_base i))) (Approximation.sin (Approximation.to_base i)), Approximation.mpow (Approximation.sinh (Approximation.msqrt (Approximation.to_base i))) Approximation.pi)) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 5 (graph 11 11 11 11)
100.000%

Elapsed Time: 153 sec
Graph (size = 9)
Generation: 2
Solution: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.three Approximation.three) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.zero Approximation.one Approximation.one) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.one Approximation.one Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Approximation.mpow Approximation.three (Approximation.sinh (Approximation.to_base i))) (Approximation.sin (Approximation.mpow (Approximation.mpow Approximation.two (Approximation.log (Approximation.to_base i))) (Approximation.cos (Approximation.to_base i)))), Algebra.sub (Approximation.exp (Approximation.sin (Approximation.exp (Algebra.sub (Approximation.sinh (Algebra.sub (Approximation.sin (Approximation.sin (Algebra.sub (Approximation.msqrt (Approximation.cosh (Approximation.msqrt (Approximation.to_base i)))) Approximation.two))) Approximation.e)) Approximation.e)))) Approximation.one)) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 5 (graph 11 11 11 11)
Using GP to obtain Graph (size = 10) with minimal RCN.
scheme: fun Mx My Mz Gx Gy -> let Mx = Mx in let My = My in let Mz = Mz in let Gx = Gx in let Gy = Gy in let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Mx (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x (ax - 1) ay az agraph) (y (ax - 1) ay az agraph) (z (ax - 1) ay az agraph)) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else My (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x ax (ay - 1) az agraph) (y ax (ay - 1) az agraph) (z ax (ay - 1) az agraph)) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Mz (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x ax ay (az - 1) agraph) (y ax ay (az - 1) agraph) (z ax ay (az - 1) agraph)) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> List.map (fun i -> let xi = x ax ay az (agraph - 1) i in let yi = y ax ay az (agraph - 1) i in let zi = z ax ay az (agraph - 1) i in let cx = Gx i Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det xi yi zi in let cy = Gy i Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det xi yi zi in (cx, cy)) |> let state = Some(Graph.empty_graph) in fun list -> List.fold Graph.add_vertex state list) in fun () -> Program.fitness 6 (graph 12 12 12 12)

             term_size: 7

             population_size: 1000

             generations: 10000

             bests: 20

             mutation_prob: 0.100

             timeout: 120.1 sec

             load_file: Some "pool9.save"

             save_file: pool10.save

Building initial population...
Deserializing GP pool
Graph (size = 10)
Generation: 1
Best individual: 10816.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else x (ax - 1) ay az agraph (n - 1)) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.three Approximation.three) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.two Approximation.e Approximation.one) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Approximation.mpow Approximation.three (Approximation.sinh (Approximation.to_base i))) (Approximation.sin (Approximation.to_base i)), Algebra.sub (Approximation.msqrt (Approximation.exp (Approximation.to_base i))) Approximation.one)) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 6 (graph 12 12 12 12)
100.000%

Elapsed Time: 162 sec
Graph (size = 10)
Generation: 2
Solution: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.pi Approximation.three Approximation.three) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.zero Approximation.two Approximation.two) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.two Approximation.pi Approximation.pi) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Approximation.mpow Approximation.three (Approximation.sinh (Algebra.mul (Algebra.add Approximation.three (Approximation.msqrt (Approximation.to_base i))) (Approximation.cos (Approximation.to_base i))))) (Approximation.sin (Approximation.to_base i)), Algebra.sub (Approximation.exp (Approximation.sin (Approximation.exp (Approximation.to_base i)))) Approximation.one)) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 6 (graph 12 12 12 12)
Using GP to obtain Graph (size = 11) with minimal RCN.
scheme: fun Mx My Mz Gx Gy -> let Mx = Mx in let My = My in let Mz = Mz in let Gx = Gx in let Gy = Gy in let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Mx (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x (ax - 1) ay az agraph) (y (ax - 1) ay az agraph) (z (ax - 1) ay az agraph)) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else My (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x ax (ay - 1) az agraph) (y ax (ay - 1) az agraph) (z ax (ay - 1) az agraph)) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Mz (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x ax ay (az - 1) agraph) (y ax ay (az - 1) agraph) (z ax ay (az - 1) agraph)) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> List.map (fun i -> let xi = x ax ay az (agraph - 1) i in let yi = y ax ay az (agraph - 1) i in let zi = z ax ay az (agraph - 1) i in let cx = Gx i Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det xi yi zi in let cy = Gy i Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det xi yi zi in (cx, cy)) |> let state = Some(Graph.empty_graph) in fun list -> List.fold Graph.add_vertex state list) in fun () -> Program.fitness 7 (graph 13 13 13 13)

             term_size: 7

             population_size: 1000

             generations: 10000

             bests: 20

             mutation_prob: 0.100

             timeout: 120.1 sec

             load_file: Some "pool10.save"

             save_file: pool11.save

Building initial population...
Deserializing GP pool
Graph (size = 11)
Generation: 1
Best individual: 34225.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.pi Approximation.pi) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.one Approximation.one) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.two Approximation.two Approximation.three) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.mul (Algebra.sub Approximation.e (Approximation.msqrt (Approximation.to_base i))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.msqrt (Approximation.cosh (Approximation.to_base i)))) Approximation.e)) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 7 (graph 13 13 13 13)
100.000%

Elapsed Time: 145 sec
Graph (size = 11)
Generation: 2
Best individual: 93025.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.pi Approximation.pi) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.two Approximation.two) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.two Approximation.two Approximation.three) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.mul (Algebra.sub Approximation.e (Approximation.msqrt (Approximation.to_base i))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.msqrt (Approximation.cosh (Approximation.to_base i)))) Approximation.e)) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 7 (graph 13 13 13 13)
100.000%

Elapsed Time: 157 sec
Graph (size = 11)
Generation: 3
Solution: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.one Approximation.one) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.pi Approximation.two Approximation.two) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.e Approximation.e Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.mul (Approximation.mpow Approximation.e (Approximation.cos (Approximation.to_base i))) (Approximation.cos (Approximation.to_base i)), Approximation.cosh (Approximation.msqrt (Approximation.cosh (Approximation.to_base i))))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 7 (graph 13 13 13 13)
Using GP to obtain Graph (size = 12) with minimal RCN.
scheme: fun Mx My Mz Gx Gy -> let Mx = Mx in let My = My in let Mz = Mz in let Gx = Gx in let Gy = Gy in let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Mx (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x (ax - 1) ay az agraph) (y (ax - 1) ay az agraph) (z (ax - 1) ay az agraph)) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else My (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x ax (ay - 1) az agraph) (y ax (ay - 1) az agraph) (z ax (ay - 1) az agraph)) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Mz (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x ax ay (az - 1) agraph) (y ax ay (az - 1) agraph) (z ax ay (az - 1) agraph)) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> List.map (fun i -> let xi = x ax ay az (agraph - 1) i in let yi = y ax ay az (agraph - 1) i in let zi = z ax ay az (agraph - 1) i in let cx = Gx i Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det xi yi zi in let cy = Gy i Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det xi yi zi in (cx, cy)) |> let state = Some(Graph.empty_graph) in fun list -> List.fold Graph.add_vertex state list) in fun () -> Program.fitness 8 (graph 14 14 14 14)

             term_size: 7

             population_size: 1000

             generations: 10000

             bests: 20

             mutation_prob: 0.100

             timeout: 120.2 sec

             load_file: Some "pool11.save"

             save_file: pool12.save

Building initial population...
Deserializing GP pool
Graph (size = 12)
Generation: 1
Best individual: 93025.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.pi Approximation.pi) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.two Approximation.two) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.two Approximation.two Approximation.three) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.mul (Algebra.sub Approximation.e (Approximation.msqrt (Approximation.to_base i))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.msqrt (Approximation.cosh (Approximation.to_base i)))) Approximation.e)) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 8 (graph 14 14 14 14)
100.000%

Elapsed Time: 149 sec
Graph (size = 12)
Generation: 2
Best individual: 198025.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.pi Approximation.pi Approximation.pi) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.two Approximation.two) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.e Approximation.e Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.sub (Algebra.div Approximation.three (Approximation.log (Approximation.to_base i))) (Approximation.cos (Algebra.dot (z ax ay az (agraph - 1) i) (z ax ay az (agraph - 1) i))), Approximation.cosh (Approximation.msqrt (Approximation.cosh (Approximation.to_base i))))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 8 (graph 14 14 14 14)
100.000%

Elapsed Time: 146 sec
Graph (size = 12)
Generation: 3
Best individual: 198025.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.pi Approximation.pi Approximation.pi) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.two Approximation.two) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.e Approximation.e Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.sub (Algebra.div Approximation.three (Approximation.log (Approximation.to_base i))) (Approximation.cos (Algebra.dot (z ax ay az (agraph - 1) i) (z ax ay az (agraph - 1) i))), Approximation.cosh (Approximation.msqrt (Approximation.cosh (Approximation.to_base i))))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 8 (graph 14 14 14 14)
100.000%

Elapsed Time: 177 sec
Graph (size = 12)
Generation: 4
Best individual: 202500.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.pi Approximation.one) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.pi Approximation.pi Approximation.two) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.pi Approximation.pi Approximation.pi) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Approximation.mpow (Algebra.sub Approximation.three (Approximation.log (Approximation.to_base i))) (Approximation.log (Approximation.to_base i)), Approximation.exp (Approximation.msqrt (Approximation.exp (Approximation.to_base i))))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 8 (graph 14 14 14 14)
100.000%

Elapsed Time: 162 sec
Graph (size = 12)
Generation: 5
Best individual: 211600.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.two Approximation.two) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.pi Approximation.pi Approximation.pi) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.e Approximation.pi Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.mul (Algebra.sub Approximation.e (Approximation.cosh (Approximation.to_base i))) (Approximation.log (Approximation.to_base i)), Approximation.cosh (Approximation.msqrt (Algebra.mul (Approximation.exp (Approximation.log (Approximation.exp (Approximation.to_base i)))) Approximation.e)))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 8 (graph 14 14 14 14)
100.000%

Elapsed Time: 162 sec
Graph (size = 12)
Generation: 6
Best individual: 211600.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.two Approximation.two) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.pi Approximation.pi Approximation.pi) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.e Approximation.pi Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.mul (Algebra.sub Approximation.e (Approximation.cosh (Approximation.to_base i))) (Approximation.log (Approximation.to_base i)), Approximation.cosh (Approximation.msqrt (Algebra.mul (Approximation.exp (Approximation.log (Approximation.exp (Approximation.to_base i)))) Approximation.e)))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 8 (graph 14 14 14 14)
100.000%

Elapsed Time: 156 sec
Graph (size = 12)
Generation: 7
Best individual: 211600.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.two Approximation.two) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.pi Approximation.pi Approximation.pi) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.e Approximation.pi Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.mul (Algebra.sub Approximation.e (Approximation.cosh (Approximation.to_base i))) (Approximation.log (Approximation.to_base i)), Approximation.cosh (Approximation.msqrt (Algebra.mul (Approximation.exp (Approximation.log (Approximation.exp (Approximation.to_base i)))) Approximation.e)))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 8 (graph 14 14 14 14)
100.000%

Elapsed Time: 170 sec
Graph (size = 12)
Generation: 8
Solution: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.two Approximation.two) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.two Approximation.two) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.e Approximation.e Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.sub (Algebra.div Approximation.three (Approximation.log (Approximation.to_base i))) (Approximation.cos (Algebra.div (Algebra.mul Approximation.one (Approximation.cosh (Approximation.to_base i))) (Approximation.sin (Approximation.to_base i)))), Approximation.cosh (Approximation.msqrt (Approximation.cosh (Approximation.to_base i))))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 8 (graph 14 14 14 14)
Using GP to obtain Graph (size = 13) with minimal RCN.
scheme: fun Mx My Mz Gx Gy -> let Mx = Mx in let My = My in let Mz = Mz in let Gx = Gx in let Gy = Gy in let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Mx (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x (ax - 1) ay az agraph) (y (ax - 1) ay az agraph) (z (ax - 1) ay az agraph)) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else My (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x ax (ay - 1) az agraph) (y ax (ay - 1) az agraph) (z ax (ay - 1) az agraph)) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Mz (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x ax ay (az - 1) agraph) (y ax ay (az - 1) agraph) (z ax ay (az - 1) agraph)) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> List.map (fun i -> let xi = x ax ay az (agraph - 1) i in let yi = y ax ay az (agraph - 1) i in let zi = z ax ay az (agraph - 1) i in let cx = Gx i Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det xi yi zi in let cy = Gy i Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det xi yi zi in (cx, cy)) |> let state = Some(Graph.empty_graph) in fun list -> List.fold Graph.add_vertex state list) in fun () -> Program.fitness 9 (graph 15 15 15 15)

             term_size: 7

             population_size: 1000

             generations: 10000

             bests: 20

             mutation_prob: 0.100

             timeout: 120.2 sec

             load_file: Some "pool12.save"

             save_file: pool13.save

Building initial population...
Deserializing GP pool
Graph (size = 13)
Generation: 1
Best individual: 211600.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.two Approximation.two) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.pi Approximation.pi Approximation.pi) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.e Approximation.pi Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.mul (Algebra.sub Approximation.e (Approximation.cosh (Approximation.to_base i))) (Approximation.log (Approximation.to_base i)), Approximation.cosh (Approximation.msqrt (Algebra.mul (Approximation.exp (Approximation.log (Approximation.exp (Approximation.to_base i)))) Approximation.e)))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 9 (graph 15 15 15 15)
100.000%

Elapsed Time: 171 sec
Graph (size = 13)
Generation: 2
Best individual: 461041.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.one Approximation.zero) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.pi Approximation.two Approximation.two) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.e Approximation.one Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.sub Approximation.pi (Approximation.cosh (Approximation.to_base i)), Algebra.div (Approximation.exp (Approximation.msqrt (Approximation.exp (Approximation.to_base i)))) (Approximation.sinh (Approximation.cos (Approximation.to_base i))))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 9 (graph 15 15 15 15)
100.000%

Elapsed Time: 155 sec
Graph (size = 13)
Generation: 3
Best individual: 461041.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.one Approximation.zero) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.pi Approximation.two Approximation.two) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.e Approximation.one Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.sub Approximation.pi (Approximation.cosh (Approximation.to_base i)), Algebra.div (Approximation.exp (Approximation.msqrt (Approximation.exp (Approximation.to_base i)))) (Approximation.sinh (Approximation.cos (Approximation.to_base i))))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 9 (graph 15 15 15 15)
100.000%

Elapsed Time: 147 sec
Graph (size = 13)
Generation: 4
Best individual: 461041.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.one Approximation.zero) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.pi Approximation.two Approximation.two) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.e Approximation.one Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.sub Approximation.pi (Approximation.cosh (Approximation.to_base i)), Algebra.div (Approximation.exp (Approximation.msqrt (Approximation.exp (Approximation.to_base i)))) (Approximation.sinh (Approximation.cos (Approximation.to_base i))))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 9 (graph 15 15 15 15)
100.000%

Elapsed Time: 145 sec
Graph (size = 13)
Generation: 5
Best individual: 469225.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.one Approximation.zero) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.pi Approximation.two Approximation.two) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.e Approximation.e Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.sub Approximation.pi (Approximation.cosh (Approximation.to_base i)), Algebra.div (Approximation.exp (Approximation.msqrt (Approximation.exp (Approximation.to_base i)))) (Approximation.sinh (Approximation.cos (Approximation.mpow (Approximation.cosh (Approximation.msqrt (Approximation.cosh (Approximation.log (Approximation.cosh (Approximation.to_base i)))))) Approximation.one))))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 9 (graph 15 15 15 15)
100.000%

Elapsed Time: 166 sec
Graph (size = 13)
Generation: 6
Best individual: 481636.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.one Approximation.e) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.two Approximation.two) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.one Approximation.one Approximation.one) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Approximation.mpow Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i)), Algebra.div (Approximation.exp (Approximation.msqrt (Approximation.exp (Approximation.to_base i)))) (Approximation.cos (Approximation.exp (Approximation.msqrt (Approximation.exp (Approximation.to_base i))))))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 9 (graph 15 15 15 15)
100.000%

Elapsed Time: 163 sec
Graph (size = 13)
Generation: 7
Best individual: 481636.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.one Approximation.e) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.two Approximation.two) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.one Approximation.one Approximation.one) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Approximation.mpow Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i)), Algebra.div (Approximation.exp (Approximation.msqrt (Approximation.exp (Approximation.to_base i)))) (Approximation.cos (Approximation.exp (Approximation.msqrt (Approximation.exp (Approximation.to_base i))))))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 9 (graph 15 15 15 15)
100.000%

Elapsed Time: 163 sec
Graph (size = 13)
Generation: 8
Best individual: 481636.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.one Approximation.e) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.two Approximation.two) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.one Approximation.one Approximation.one) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Approximation.mpow Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i)), Algebra.div (Approximation.exp (Approximation.msqrt (Approximation.exp (Approximation.to_base i)))) (Approximation.cos (Approximation.exp (Approximation.msqrt (Approximation.exp (Approximation.to_base i))))))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 9 (graph 15 15 15 15)
100.000%

Elapsed Time: 162 sec
Graph (size = 13)
Generation: 9
Best individual: 481636.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.one Approximation.e) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.two Approximation.two) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.one Approximation.one Approximation.one) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Approximation.mpow Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i)), Algebra.div (Approximation.exp (Approximation.msqrt (Approximation.exp (Approximation.to_base i)))) (Approximation.cos (Approximation.exp (Approximation.msqrt (Approximation.exp (Approximation.to_base i))))))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 9 (graph 15 15 15 15)
100.000%

Elapsed Time: 158 sec
Graph (size = 13)
Generation: 10
Best individual: 481636.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.one Approximation.e) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.two Approximation.two) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.one Approximation.one Approximation.one) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Approximation.mpow Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i)), Algebra.div (Approximation.exp (Approximation.msqrt (Approximation.exp (Approximation.to_base i)))) (Approximation.cos (Approximation.exp (Approximation.msqrt (Approximation.exp (Approximation.to_base i))))))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 9 (graph 15 15 15 15)
100.000%

Elapsed Time: 147 sec
Graph (size = 13)
Generation: 11
Best individual: 509796.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.two Approximation.e) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.two Approximation.two) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.two Approximation.zero Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.add (Algebra.add (Algebra.sub Approximation.e (Approximation.sinh (Approximation.to_base i))) (Approximation.msqrt (Approximation.to_base i))) (Approximation.msqrt (Approximation.to_base i))) (Algebra.mul (Algebra.add Approximation.zero (Approximation.msqrt (Approximation.to_base i))) (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Approximation.cosh (Approximation.to_base i)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.msqrt (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 9 (graph 15 15 15 15)
100.000%

Elapsed Time: 169 sec
Graph (size = 13)
Generation: 12
Best individual: 509796.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.two Approximation.e) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.two Approximation.two) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.two Approximation.zero Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.add (Algebra.add (Algebra.sub Approximation.e (Approximation.sinh (Approximation.to_base i))) (Approximation.msqrt (Approximation.to_base i))) (Approximation.msqrt (Approximation.to_base i))) (Algebra.mul (Algebra.add Approximation.zero (Approximation.msqrt (Approximation.to_base i))) (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Approximation.cosh (Approximation.to_base i)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.msqrt (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 9 (graph 15 15 15 15)
100.000%

Elapsed Time: 164 sec
Graph (size = 13)
Generation: 13
Solution: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.two Approximation.one) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.one Approximation.one) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.one Approximation.two Approximation.two) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.add (Algebra.add Approximation.zero (Algebra.mul (Approximation.exp (Approximation.to_base i)) (Approximation.cos (Approximation.to_base i)))) (Algebra.mul (Algebra.div Approximation.zero (Approximation.sin (Approximation.to_base i))) (Approximation.sin (Approximation.to_base i))), Algebra.div (Approximation.exp (Approximation.msqrt (Approximation.exp (Approximation.to_base i)))) (Approximation.cos (Approximation.exp (Approximation.msqrt (Approximation.exp (Approximation.to_base i))))))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 9 (graph 15 15 15 15)
Using GP to obtain Graph (size = 14) with minimal RCN.
scheme: fun Mx My Mz Gx Gy -> let Mx = Mx in let My = My in let Mz = Mz in let Gx = Gx in let Gy = Gy in let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Mx (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x (ax - 1) ay az agraph) (y (ax - 1) ay az agraph) (z (ax - 1) ay az agraph)) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else My (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x ax (ay - 1) az agraph) (y ax (ay - 1) az agraph) (z ax (ay - 1) az agraph)) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Mz (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x ax ay (az - 1) agraph) (y ax ay (az - 1) agraph) (z ax ay (az - 1) agraph)) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> List.map (fun i -> let xi = x ax ay az (agraph - 1) i in let yi = y ax ay az (agraph - 1) i in let zi = z ax ay az (agraph - 1) i in let cx = Gx i Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det xi yi zi in let cy = Gy i Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det xi yi zi in (cx, cy)) |> let state = Some(Graph.empty_graph) in fun list -> List.fold Graph.add_vertex state list) in fun () -> Program.fitness 10 (graph 16 16 16 16)

             term_size: 7

             population_size: 1000

             generations: 10000

             bests: 20

             mutation_prob: 0.100

             timeout: 120.2 sec

             load_file: Some "pool13.save"

             save_file: pool14.save

Building initial population...
Deserializing GP pool
Graph (size = 14)
Generation: 1
Solution: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.e Approximation.e Approximation.e) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else x ax (ay - 1) az agraph (n - 1)) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.one Approximation.one Approximation.one) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.mul (Algebra.sub Approximation.three (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Algebra.dot (z ax ay az (agraph - 1) i) (z ax ay az (agraph - 1) i))), Algebra.div (Approximation.exp (Approximation.msqrt (Approximation.exp (Approximation.to_base i)))) (Approximation.sinh (Approximation.cos (Approximation.to_base i))))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 10 (graph 16 16 16 16)
Using GP to obtain Graph (size = 15) with minimal RCN.
scheme: fun Mx My Mz Gx Gy -> let Mx = Mx in let My = My in let Mz = Mz in let Gx = Gx in let Gy = Gy in let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Mx (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x (ax - 1) ay az agraph) (y (ax - 1) ay az agraph) (z (ax - 1) ay az agraph)) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else My (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x ax (ay - 1) az agraph) (y ax (ay - 1) az agraph) (z ax (ay - 1) az agraph)) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Mz (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x ax ay (az - 1) agraph) (y ax ay (az - 1) agraph) (z ax ay (az - 1) agraph)) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> List.map (fun i -> let xi = x ax ay az (agraph - 1) i in let yi = y ax ay az (agraph - 1) i in let zi = z ax ay az (agraph - 1) i in let cx = Gx i Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det xi yi zi in let cy = Gy i Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det xi yi zi in (cx, cy)) |> let state = Some(Graph.empty_graph) in fun list -> List.fold Graph.add_vertex state list) in fun () -> Program.fitness 11 (graph 17 17 17 17)

             term_size: 7

             population_size: 1000

             generations: 10000

             bests: 20

             mutation_prob: 0.100

             timeout: 120.2 sec

             load_file: Some "pool14.save"

             save_file: pool15.save

Building initial population...
Deserializing GP pool
Graph (size = 15)
Generation: 1
Best individual: 509796.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.two Approximation.e) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.two Approximation.two) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.two Approximation.zero Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.add (Algebra.add (Algebra.sub Approximation.e (Approximation.sinh (Approximation.to_base i))) (Approximation.msqrt (Approximation.to_base i))) (Approximation.msqrt (Approximation.to_base i))) (Algebra.mul (Algebra.add Approximation.zero (Approximation.msqrt (Approximation.to_base i))) (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Approximation.cosh (Approximation.to_base i)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.msqrt (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 11 (graph 17 17 17 17)
100.000%

Elapsed Time: 163 sec
Graph (size = 15)
Generation: 2
Best individual: 1000000.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.two Approximation.e) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.zero Approximation.pi Approximation.one) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.three Approximation.two Approximation.two) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.add (Algebra.add (Algebra.sub Approximation.e (Approximation.sinh (Approximation.to_base i))) (Approximation.msqrt (Approximation.to_base i))) (Approximation.msqrt (Approximation.to_base i))) (Algebra.mul (Algebra.add Approximation.zero (Approximation.msqrt (Approximation.to_base i))) (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Approximation.cosh (Approximation.to_base i)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.msqrt (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 11 (graph 17 17 17 17)
100.000%

Elapsed Time: 159 sec
Graph (size = 15)
Generation: 3
Best individual: 1245456.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.two Approximation.e) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.three Approximation.zero) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.two Approximation.zero Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Approximation.exp (Approximation.to_base i))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Approximation.cosh (Approximation.to_base i)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 11 (graph 17 17 17 17)
100.000%

Elapsed Time: 169 sec
Graph (size = 15)
Generation: 4
Best individual: 1760929.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.zero Approximation.zero Approximation.zero) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.zero Approximation.one Approximation.zero) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.two Approximation.zero Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.add (Algebra.add (Algebra.sub Approximation.e (Approximation.sinh (Approximation.to_base i))) (Approximation.msqrt (Approximation.to_base i))) (Approximation.msqrt (Approximation.to_base i))) (Algebra.mul (Algebra.add Approximation.zero (Approximation.msqrt (Approximation.to_base i))) (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Approximation.cosh (Approximation.to_base i)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Algebra.add (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))) (Approximation.log (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 11 (graph 17 17 17 17)
100.000%

Elapsed Time: 167 sec
Graph (size = 15)
Generation: 5
Best individual: 1760929.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.zero Approximation.zero Approximation.zero) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.zero Approximation.one Approximation.zero) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.two Approximation.zero Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.add (Algebra.add (Algebra.sub Approximation.e (Approximation.sinh (Approximation.to_base i))) (Approximation.msqrt (Approximation.to_base i))) (Approximation.msqrt (Approximation.to_base i))) (Algebra.mul (Algebra.add Approximation.zero (Approximation.msqrt (Approximation.to_base i))) (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Approximation.cosh (Approximation.to_base i)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Algebra.add (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))) (Approximation.log (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 11 (graph 17 17 17 17)
100.000%

Elapsed Time: 162 sec
Graph (size = 15)
Generation: 6
Best individual: 1760929.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.zero Approximation.zero Approximation.zero) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.zero Approximation.one Approximation.zero) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.two Approximation.zero Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.add (Algebra.add (Algebra.sub Approximation.e (Approximation.sinh (Approximation.to_base i))) (Approximation.msqrt (Approximation.to_base i))) (Approximation.msqrt (Approximation.to_base i))) (Algebra.mul (Algebra.add Approximation.zero (Approximation.msqrt (Approximation.to_base i))) (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Approximation.cosh (Approximation.to_base i)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Algebra.add (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))) (Approximation.log (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 11 (graph 17 17 17 17)
100.000%

Elapsed Time: 175 sec
Graph (size = 15)
Generation: 7
Best individual: 1809025.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.pi Approximation.three) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.three Approximation.zero) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.two Approximation.zero Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Approximation.cosh (Approximation.to_base i)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 11 (graph 17 17 17 17)
100.000%

Elapsed Time: 161 sec
Graph (size = 15)
Generation: 8
Best individual: 1809025.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.pi Approximation.three) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.three Approximation.zero) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.two Approximation.zero Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Approximation.cosh (Approximation.to_base i)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 11 (graph 17 17 17 17)
100.000%

Elapsed Time: 179 sec
Graph (size = 15)
Generation: 9
Solution: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.zero Approximation.e) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.three Approximation.zero) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.two Approximation.zero Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Algebra.mul (Approximation.msqrt (Approximation.sinh (Approximation.msqrt (Approximation.to_base i)))) (Algebra.mul (Approximation.sinh (Approximation.sinh (Approximation.msqrt (Approximation.msqrt (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 11 (graph 17 17 17 17)
Using GP to obtain Graph (size = 16) with minimal RCN.
scheme: fun Mx My Mz Gx Gy -> let Mx = Mx in let My = My in let Mz = Mz in let Gx = Gx in let Gy = Gy in let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Mx (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x (ax - 1) ay az agraph) (y (ax - 1) ay az agraph) (z (ax - 1) ay az agraph)) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else My (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x ax (ay - 1) az agraph) (y ax (ay - 1) az agraph) (z ax (ay - 1) az agraph)) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Mz (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x ax ay (az - 1) agraph) (y ax ay (az - 1) agraph) (z ax ay (az - 1) agraph)) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> List.map (fun i -> let xi = x ax ay az (agraph - 1) i in let yi = y ax ay az (agraph - 1) i in let zi = z ax ay az (agraph - 1) i in let cx = Gx i Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det xi yi zi in let cy = Gy i Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det xi yi zi in (cx, cy)) |> let state = Some(Graph.empty_graph) in fun list -> List.fold Graph.add_vertex state list) in fun () -> Program.fitness 12 (graph 18 18 18 18)

             term_size: 7

             population_size: 1000

             generations: 10000

             bests: 20

             mutation_prob: 0.100

             timeout: 120.2 sec

             load_file: Some "pool15.save"

             save_file: pool16.save

Building initial population...
Deserializing GP pool
Graph (size = 16)
Generation: 1
Best individual: 1809025.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.pi Approximation.three) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.three Approximation.zero) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.two Approximation.zero Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Approximation.cosh (Approximation.to_base i)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 12 (graph 18 18 18 18)
100.000%

Elapsed Time: 160 sec
Graph (size = 16)
Generation: 2
Best individual: 3240000.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.pi Approximation.three) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.three Approximation.three) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.one Approximation.two Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Approximation.cosh (Approximation.to_base i)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 12 (graph 18 18 18 18)
100.000%

Elapsed Time: 182 sec
Graph (size = 16)
Generation: 3
Best individual: 3240000.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.pi Approximation.three) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.three Approximation.three) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.one Approximation.two Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Approximation.cosh (Approximation.to_base i)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 12 (graph 18 18 18 18)
100.000%

Elapsed Time: 173 sec
Graph (size = 16)
Generation: 4
Best individual: 3243601.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.pi Approximation.three) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.three Approximation.three) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.zero Approximation.zero Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Approximation.exp (Algebra.sub Approximation.zero (Approximation.mpow (Algebra.sub (Algebra.add Approximation.zero (Approximation.log (Approximation.to_base i))) (Approximation.log (Algebra.div (Algebra.div Approximation.zero (Approximation.cos (Approximation.to_base i))) (Approximation.cos (Approximation.to_base i))))) (Approximation.to_base i))))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Approximation.cosh (Approximation.to_base i)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 12 (graph 18 18 18 18)
100.000%

Elapsed Time: 162 sec
Graph (size = 16)
Generation: 5
Solution: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.pi Approximation.one Approximation.e) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.pi Approximation.pi Approximation.three) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.zero Approximation.e Approximation.one) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub (Algebra.sub (Algebra.div Approximation.pi (Approximation.exp (Approximation.to_base i))) (Approximation.cos (Approximation.to_base i))) (Approximation.cos (Approximation.to_base i))) (Algebra.sub (Algebra.sub Approximation.zero (Approximation.cos (Approximation.to_base i))) (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Approximation.cosh (Approximation.to_base i)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Algebra.add (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))) (Approximation.log (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 12 (graph 18 18 18 18)
Using GP to obtain Graph (size = 17) with minimal RCN.
scheme: fun Mx My Mz Gx Gy -> let Mx = Mx in let My = My in let Mz = Mz in let Gx = Gx in let Gy = Gy in let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Mx (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x (ax - 1) ay az agraph) (y (ax - 1) ay az agraph) (z (ax - 1) ay az agraph)) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else My (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x ax (ay - 1) az agraph) (y ax (ay - 1) az agraph) (z ax (ay - 1) az agraph)) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Mz (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x ax ay (az - 1) agraph) (y ax ay (az - 1) agraph) (z ax ay (az - 1) agraph)) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> List.map (fun i -> let xi = x ax ay az (agraph - 1) i in let yi = y ax ay az (agraph - 1) i in let zi = z ax ay az (agraph - 1) i in let cx = Gx i Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det xi yi zi in let cy = Gy i Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det xi yi zi in (cx, cy)) |> let state = Some(Graph.empty_graph) in fun list -> List.fold Graph.add_vertex state list) in fun () -> Program.fitness 13 (graph 19 19 19 19)

             term_size: 7

             population_size: 1000

             generations: 10000

             bests: 20

             mutation_prob: 0.100

             timeout: 120.3 sec

             load_file: Some "pool16.save"

             save_file: pool17.save

Building initial population...
Deserializing GP pool
Graph (size = 17)
Generation: 1
Best individual: 3243601.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.pi Approximation.three) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.three Approximation.three) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.zero Approximation.zero Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Approximation.exp (Algebra.sub Approximation.zero (Approximation.mpow (Algebra.sub (Algebra.add Approximation.zero (Approximation.log (Approximation.to_base i))) (Approximation.log (Algebra.div (Algebra.div Approximation.zero (Approximation.cos (Approximation.to_base i))) (Approximation.cos (Approximation.to_base i))))) (Approximation.to_base i))))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Approximation.cosh (Approximation.to_base i)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 13 (graph 19 19 19 19)
100.000%

Elapsed Time: 181 sec
Graph (size = 17)
Generation: 2
Best individual: 5574321.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.pi Approximation.one) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.three Approximation.three) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.zero Approximation.zero Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Approximation.exp (Algebra.sub Approximation.zero (Approximation.mpow (Algebra.sub (Algebra.add Approximation.zero (Approximation.log (Approximation.to_base i))) (Approximation.log (Algebra.div (Algebra.div Approximation.zero (Approximation.cos (Approximation.to_base i))) (Approximation.cos (Approximation.to_base i))))) (Approximation.to_base i))))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Approximation.cosh (Approximation.to_base i)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 13 (graph 19 19 19 19)
100.000%

Elapsed Time: 179 sec
Graph (size = 17)
Generation: 3
Best individual: 5574321.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.pi Approximation.one) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.three Approximation.three) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.zero Approximation.zero Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Approximation.exp (Algebra.sub Approximation.zero (Approximation.mpow (Algebra.sub (Algebra.add Approximation.zero (Approximation.log (Approximation.to_base i))) (Approximation.log (Algebra.div (Algebra.div Approximation.zero (Approximation.cos (Approximation.to_base i))) (Approximation.cos (Approximation.to_base i))))) (Approximation.to_base i))))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Approximation.cosh (Approximation.to_base i)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 13 (graph 19 19 19 19)
100.000%

Elapsed Time: 192 sec
Graph (size = 17)
Generation: 4
Best individual: 5574321.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.pi Approximation.one) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.three Approximation.three) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.zero Approximation.zero Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Approximation.exp (Algebra.sub Approximation.zero (Approximation.mpow (Algebra.sub (Algebra.add Approximation.zero (Approximation.log (Approximation.to_base i))) (Approximation.log (Algebra.div (Algebra.div Approximation.zero (Approximation.cos (Approximation.to_base i))) (Approximation.cos (Approximation.to_base i))))) (Approximation.to_base i))))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Approximation.cosh (Approximation.to_base i)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 13 (graph 19 19 19 19)
100.000%

Elapsed Time: 183 sec
Graph (size = 17)
Generation: 5
Best individual: 5574321.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.pi Approximation.one) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.three Approximation.three) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.zero Approximation.zero Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Approximation.exp (Algebra.sub Approximation.zero (Approximation.mpow (Algebra.sub (Algebra.add Approximation.zero (Approximation.log (Approximation.to_base i))) (Approximation.log (Algebra.div (Algebra.div Approximation.zero (Approximation.cos (Approximation.to_base i))) (Approximation.cos (Approximation.to_base i))))) (Approximation.to_base i))))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Approximation.cosh (Approximation.to_base i)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 13 (graph 19 19 19 19)
99.898%

Elapsed Time: 192 sec
Graph (size = 17)
Generation: 6
Solution: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.e Approximation.zero) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.pi Approximation.one) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.two Approximation.zero Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.mpow Approximation.pi (Approximation.mpow (Approximation.mpow Approximation.pi (Approximation.mpow (Approximation.mpow (Approximation.mpow (Approximation.mpow Approximation.pi (Approximation.cos (Approximation.to_base i))) (Approximation.cos (Approximation.to_base i))) (Approximation.cos (Approximation.to_base i))) (Approximation.mpow (Approximation.mpow Approximation.three (Approximation.mpow (Approximation.mpow (Approximation.mpow (Approximation.mpow Approximation.pi (Approximation.msqrt (Approximation.to_base i))) (Approximation.log (Approximation.to_base i))) (Approximation.log (Approximation.to_base i))) (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i))))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Approximation.cosh (Approximation.to_base i)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 13 (graph 19 19 19 19)
Using GP to obtain Graph (size = 18) with minimal RCN.
scheme: fun Mx My Mz Gx Gy -> let Mx = Mx in let My = My in let Mz = Mz in let Gx = Gx in let Gy = Gy in let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Mx (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x (ax - 1) ay az agraph) (y (ax - 1) ay az agraph) (z (ax - 1) ay az agraph)) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else My (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x ax (ay - 1) az agraph) (y ax (ay - 1) az agraph) (z ax (ay - 1) az agraph)) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Mz (n - 1) Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det (x ax ay (az - 1) agraph) (y ax ay (az - 1) agraph) (z ax ay (az - 1) agraph)) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> List.map (fun i -> let xi = x ax ay az (agraph - 1) i in let yi = y ax ay az (agraph - 1) i in let zi = z ax ay az (agraph - 1) i in let cx = Gx i Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det xi yi zi in let cy = Gy i Approximation.to_base Approximation.zero Approximation.one Approximation.two Approximation.three Approximation.pi Approximation.e Algebra.add Algebra.sub Algebra.div Algebra.mul Approximation.sin Approximation.cos Approximation.sinh Approximation.cosh Approximation.log Approximation.exp Approximation.msqrt Approximation.mpow Algebra.mk_vector3D Algebra.mk_matrix Approximation.v_x Approximation.v_y Approximation.v_z Algebra.v_add Algebra.v_sub Algebra.dot Algebra.cross Algebra.v_norm Algebra.identity Algebra.m_add Algebra.m_sub Algebra.multiplyM Algebra.multiplyV Algebra.translate Algebra.scale Algebra.rotate Algebra.hrotate Algebra.transpose Algebra.det xi yi zi in (cx, cy)) |> let state = Some(Graph.empty_graph) in fun list -> List.fold Graph.add_vertex state list) in fun () -> Program.fitness 14 (graph 20 20 20 20)

             term_size: 7

             population_size: 1000

             generations: 10000

             bests: 20

             mutation_prob: 0.100

             timeout: 120.3 sec

             load_file: Some "pool17.save"

             save_file: pool18.save

Building initial population...
Deserializing GP pool
Graph (size = 18)
Generation: 1
Best individual: 5574321.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.pi Approximation.one) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.three Approximation.three) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.zero Approximation.zero Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Approximation.exp (Algebra.sub Approximation.zero (Approximation.mpow (Algebra.sub (Algebra.add Approximation.zero (Approximation.log (Approximation.to_base i))) (Approximation.log (Algebra.div (Algebra.div Approximation.zero (Approximation.cos (Approximation.to_base i))) (Approximation.cos (Approximation.to_base i))))) (Approximation.to_base i))))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Approximation.cosh (Approximation.to_base i)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 14 (graph 20 20 20 20)
100.000%

Elapsed Time: 189 sec
Graph (size = 18)
Generation: 2
Best individual: 9150625.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.one Approximation.two) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.three Approximation.three) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D (Approximation.exp (Approximation.cosh (Approximation.cosh Approximation.zero))) Approximation.three Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Algebra.mul (Algebra.div Approximation.three (Algebra.mul (Algebra.mul (Algebra.mul (Algebra.add Approximation.three (Approximation.sin (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.mpow (Algebra.mul Approximation.three (Approximation.sinh (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.sinh (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Algebra.add (Approximation.msqrt (Approximation.exp (Approximation.exp (Approximation.log (Algebra.add (Approximation.sin (Approximation.exp (Approximation.sin (Approximation.to_base i)))) (Algebra.add (Approximation.cos (Approximation.cos (Approximation.msqrt (Approximation.exp (Approximation.msqrt (Approximation.to_base i)))))) Approximation.two)))))) (Algebra.add (Approximation.cos (Approximation.cos (Algebra.add (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))) (Approximation.exp (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))))))) Approximation.pi)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 14 (graph 20 20 20 20)
100.000%

Elapsed Time: 197 sec
Graph (size = 18)
Generation: 3
Best individual: 9150625.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.one Approximation.two) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.three Approximation.three) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D (Approximation.exp (Approximation.cosh (Approximation.cosh Approximation.zero))) Approximation.three Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Algebra.mul (Algebra.div Approximation.three (Algebra.mul (Algebra.mul (Algebra.mul (Algebra.add Approximation.three (Approximation.sin (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.mpow (Algebra.mul Approximation.three (Approximation.sinh (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.sinh (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Algebra.add (Approximation.msqrt (Approximation.exp (Approximation.exp (Approximation.log (Algebra.add (Approximation.sin (Approximation.exp (Approximation.sin (Approximation.to_base i)))) (Algebra.add (Approximation.cos (Approximation.cos (Approximation.msqrt (Approximation.exp (Approximation.msqrt (Approximation.to_base i)))))) Approximation.two)))))) (Algebra.add (Approximation.cos (Approximation.cos (Algebra.add (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))) (Approximation.exp (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))))))) Approximation.pi)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 14 (graph 20 20 20 20)
100.000%

Elapsed Time: 191 sec
Graph (size = 18)
Generation: 4
Best individual: 9150625.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.one Approximation.two) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.three Approximation.three) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D (Approximation.exp (Approximation.cosh (Approximation.cosh Approximation.zero))) Approximation.three Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Algebra.mul (Algebra.div Approximation.three (Algebra.mul (Algebra.mul (Algebra.mul (Algebra.add Approximation.three (Approximation.sin (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.mpow (Algebra.mul Approximation.three (Approximation.sinh (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.sinh (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Algebra.add (Approximation.msqrt (Approximation.exp (Approximation.exp (Approximation.log (Algebra.add (Approximation.sin (Approximation.exp (Approximation.sin (Approximation.to_base i)))) (Algebra.add (Approximation.cos (Approximation.cos (Approximation.msqrt (Approximation.exp (Approximation.msqrt (Approximation.to_base i)))))) Approximation.two)))))) (Algebra.add (Approximation.cos (Approximation.cos (Algebra.add (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))) (Approximation.exp (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))))))) Approximation.pi)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 14 (graph 20 20 20 20)
100.000%

Elapsed Time: 195 sec
Graph (size = 18)
Generation: 5
Best individual: 9150625.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.one Approximation.two) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.three Approximation.three) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D (Approximation.exp (Approximation.cosh (Approximation.cosh Approximation.zero))) Approximation.three Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Algebra.mul (Algebra.div Approximation.three (Algebra.mul (Algebra.mul (Algebra.mul (Algebra.add Approximation.three (Approximation.sin (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.mpow (Algebra.mul Approximation.three (Approximation.sinh (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.sinh (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Algebra.add (Approximation.msqrt (Approximation.exp (Approximation.exp (Approximation.log (Algebra.add (Approximation.sin (Approximation.exp (Approximation.sin (Approximation.to_base i)))) (Algebra.add (Approximation.cos (Approximation.cos (Approximation.msqrt (Approximation.exp (Approximation.msqrt (Approximation.to_base i)))))) Approximation.two)))))) (Algebra.add (Approximation.cos (Approximation.cos (Algebra.add (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))) (Approximation.exp (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))))))) Approximation.pi)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 14 (graph 20 20 20 20)
100.000%

Elapsed Time: 187 sec
Graph (size = 18)
Generation: 6
Best individual: 9150625.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.one Approximation.two) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.three Approximation.three) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D (Approximation.exp (Approximation.cosh (Approximation.cosh Approximation.zero))) Approximation.three Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Algebra.mul (Algebra.div Approximation.three (Algebra.mul (Algebra.mul (Algebra.mul (Algebra.add Approximation.three (Approximation.sin (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.mpow (Algebra.mul Approximation.three (Approximation.sinh (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.sinh (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Algebra.add (Approximation.msqrt (Approximation.exp (Approximation.exp (Approximation.log (Algebra.add (Approximation.sin (Approximation.exp (Approximation.sin (Approximation.to_base i)))) (Algebra.add (Approximation.cos (Approximation.cos (Approximation.msqrt (Approximation.exp (Approximation.msqrt (Approximation.to_base i)))))) Approximation.two)))))) (Algebra.add (Approximation.cos (Approximation.cos (Algebra.add (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))) (Approximation.exp (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))))))) Approximation.pi)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 14 (graph 20 20 20 20)
100.000%

Elapsed Time: 213 sec
Graph (size = 18)
Generation: 7
Best individual: 9150625.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.one Approximation.two) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.three Approximation.three) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D (Approximation.exp (Approximation.cosh (Approximation.cosh Approximation.zero))) Approximation.three Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Algebra.mul (Algebra.div Approximation.three (Algebra.mul (Algebra.mul (Algebra.mul (Algebra.add Approximation.three (Approximation.sin (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.mpow (Algebra.mul Approximation.three (Approximation.sinh (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.sinh (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Algebra.add (Approximation.msqrt (Approximation.exp (Approximation.exp (Approximation.log (Algebra.add (Approximation.sin (Approximation.exp (Approximation.sin (Approximation.to_base i)))) (Algebra.add (Approximation.cos (Approximation.cos (Approximation.msqrt (Approximation.exp (Approximation.msqrt (Approximation.to_base i)))))) Approximation.two)))))) (Algebra.add (Approximation.cos (Approximation.cos (Algebra.add (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))) (Approximation.exp (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))))))) Approximation.pi)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 14 (graph 20 20 20 20)
100.000%

Elapsed Time: 218 sec
Graph (size = 18)
Generation: 8
Best individual: 9162729.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.one Approximation.one) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.three Approximation.three) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.two Approximation.two Approximation.two) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Algebra.mul (Algebra.div Approximation.three (Algebra.mul (Algebra.mul (Algebra.mul (Algebra.add Approximation.three (Approximation.sin (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.mpow (Algebra.mul Approximation.three (Approximation.sinh (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.sinh (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Algebra.add (Approximation.msqrt (Approximation.exp (Approximation.exp (Approximation.log (Algebra.add (Approximation.sin (Approximation.exp (Approximation.sin (Approximation.to_base i)))) (Algebra.add (Approximation.cos (Approximation.cos (Approximation.msqrt (Approximation.exp (Approximation.msqrt (Approximation.to_base i)))))) Approximation.two)))))) (Algebra.add (Approximation.cos (Algebra.add (Approximation.log (Approximation.cosh (Approximation.log (Approximation.to_base i)))) (Algebra.add (Approximation.exp (Approximation.exp (Approximation.cos (Approximation.cosh (Approximation.cos (Approximation.to_base i)))))) Approximation.pi))) Approximation.pi)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 14 (graph 20 20 20 20)
100.000%

Elapsed Time: 229 sec
Graph (size = 18)
Generation: 9
Best individual: 9162729.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.one Approximation.one) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.three Approximation.three Approximation.three) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.two Approximation.two Approximation.two) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Algebra.mul (Algebra.div Approximation.three (Algebra.mul (Algebra.mul (Algebra.mul (Algebra.add Approximation.three (Approximation.sin (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.mpow (Algebra.mul Approximation.three (Approximation.sinh (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.sinh (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Algebra.add (Approximation.msqrt (Approximation.exp (Approximation.exp (Approximation.log (Algebra.add (Approximation.sin (Approximation.exp (Approximation.sin (Approximation.to_base i)))) (Algebra.add (Approximation.cos (Approximation.cos (Approximation.msqrt (Approximation.exp (Approximation.msqrt (Approximation.to_base i)))))) Approximation.two)))))) (Algebra.add (Approximation.cos (Algebra.add (Approximation.log (Approximation.cosh (Approximation.log (Approximation.to_base i)))) (Algebra.add (Approximation.exp (Approximation.exp (Approximation.cos (Approximation.cosh (Approximation.cos (Approximation.to_base i)))))) Approximation.pi))) Approximation.pi)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 14 (graph 20 20 20 20)
100.000%

Elapsed Time: 229 sec
Graph (size = 18)
Generation: 10
Best individual: 9205156.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.one Approximation.one) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.pi Approximation.two) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.pi Approximation.one Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Algebra.mul (Algebra.div Approximation.three (Algebra.mul (Algebra.mul (Algebra.mul (Algebra.add Approximation.three (Approximation.sin (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.mpow (Algebra.mul Approximation.three (Approximation.sinh (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.sinh (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Algebra.sub (Approximation.sinh (Approximation.cos (Approximation.sinh (Approximation.to_base i)))) (Algebra.sub (Approximation.sinh (Approximation.sinh (Approximation.cosh (Approximation.cos (Approximation.cosh (Approximation.to_base i)))))) Approximation.pi))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 14 (graph 20 20 20 20)
100.000%

Elapsed Time: 256 sec
Graph (size = 18)
Generation: 11
Best individual: 9205156.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.one Approximation.one) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.pi Approximation.two) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.pi Approximation.one Approximation.e) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Algebra.mul (Algebra.div Approximation.three (Algebra.mul (Algebra.mul (Algebra.mul (Algebra.add Approximation.three (Approximation.sin (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.mpow (Algebra.mul Approximation.three (Approximation.sinh (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.sinh (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Algebra.sub (Approximation.sinh (Approximation.cos (Approximation.sinh (Approximation.to_base i)))) (Algebra.sub (Approximation.sinh (Approximation.sinh (Approximation.cosh (Approximation.cos (Approximation.cosh (Approximation.to_base i)))))) Approximation.pi))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 14 (graph 20 20 20 20)
100.000%

Elapsed Time: 245 sec
Graph (size = 18)
Generation: 12
Best individual: 9247681.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.one Approximation.one) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.e Approximation.e Approximation.e) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.two Approximation.pi (Approximation.sin (Algebra.add Approximation.one Approximation.pi))) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Algebra.mul (Algebra.div Approximation.three (Algebra.mul (Algebra.mul (Algebra.mul (Algebra.add Approximation.three (Approximation.sin (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.sinh (Algebra.div Approximation.e Approximation.e))) (Approximation.mpow (Algebra.mul Approximation.three (Approximation.sinh (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.sinh (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Algebra.add (Approximation.msqrt (Approximation.exp (Algebra.sub (Approximation.exp (Approximation.sin (Approximation.exp (Approximation.to_base i)))) (Algebra.sub (Approximation.cos (Approximation.cos (Approximation.cos (Approximation.sin (Approximation.cos (Approximation.to_base i)))))) Approximation.three)))) (Algebra.add (Approximation.cos (Approximation.cos (Algebra.add (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))) (Approximation.exp (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))))))) Approximation.pi)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 14 (graph 20 20 20 20)
100.000%

Elapsed Time: 270 sec
Graph (size = 18)
Generation: 13
Best individual: 9247681.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.one Approximation.one) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.e Approximation.e Approximation.e) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.two Approximation.pi (Approximation.sin (Algebra.add Approximation.one Approximation.pi))) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Algebra.mul (Algebra.div Approximation.three (Algebra.mul (Algebra.mul (Algebra.mul (Algebra.add Approximation.three (Approximation.sin (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.sinh (Algebra.div Approximation.e Approximation.e))) (Approximation.mpow (Algebra.mul Approximation.three (Approximation.sinh (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.sinh (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Algebra.add (Approximation.msqrt (Approximation.exp (Algebra.sub (Approximation.exp (Approximation.sin (Approximation.exp (Approximation.to_base i)))) (Algebra.sub (Approximation.cos (Approximation.cos (Approximation.cos (Approximation.sin (Approximation.cos (Approximation.to_base i)))))) Approximation.three)))) (Algebra.add (Approximation.cos (Approximation.cos (Algebra.add (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))) (Approximation.exp (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))))))) Approximation.pi)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 14 (graph 20 20 20 20)
100.000%

Elapsed Time: 303 sec
Graph (size = 18)
Generation: 14
Best individual: 9247681.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.one Approximation.one) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.e Approximation.e Approximation.e) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.two Approximation.pi (Approximation.sin (Algebra.add Approximation.one Approximation.pi))) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Algebra.mul (Algebra.div Approximation.three (Algebra.mul (Algebra.mul (Algebra.mul (Algebra.add Approximation.three (Approximation.sin (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.sinh (Algebra.div Approximation.e Approximation.e))) (Approximation.mpow (Algebra.mul Approximation.three (Approximation.sinh (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.sinh (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Algebra.add (Approximation.msqrt (Approximation.exp (Algebra.sub (Approximation.exp (Approximation.sin (Approximation.exp (Approximation.to_base i)))) (Algebra.sub (Approximation.cos (Approximation.cos (Approximation.cos (Approximation.sin (Approximation.cos (Approximation.to_base i)))))) Approximation.three)))) (Algebra.add (Approximation.cos (Approximation.cos (Algebra.add (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))) (Approximation.exp (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))))))) Approximation.pi)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 14 (graph 20 20 20 20)
100.000%

Elapsed Time: 334 sec
Graph (size = 18)
Generation: 15
Best individual: 9247681.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.one Approximation.one) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.e Approximation.e Approximation.e) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.two Approximation.pi (Approximation.sin (Algebra.add Approximation.one Approximation.pi))) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Algebra.mul (Algebra.div Approximation.three (Algebra.mul (Algebra.mul (Algebra.mul (Algebra.add Approximation.three (Approximation.sin (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.sinh (Algebra.div Approximation.e Approximation.e))) (Approximation.mpow (Algebra.mul Approximation.three (Approximation.sinh (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.sinh (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Algebra.add (Approximation.msqrt (Approximation.exp (Algebra.sub (Approximation.exp (Approximation.sin (Approximation.exp (Approximation.to_base i)))) (Algebra.sub (Approximation.cos (Approximation.cos (Approximation.cos (Approximation.sin (Approximation.cos (Approximation.to_base i)))))) Approximation.three)))) (Algebra.add (Approximation.cos (Approximation.cos (Algebra.add (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))) (Approximation.exp (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))))))) Approximation.pi)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 14 (graph 20 20 20 20)
100.000%

Elapsed Time: 374 sec
Graph (size = 18)
Generation: 16
Best individual: 9247681.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.one Approximation.one) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.e Approximation.e Approximation.e) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.two Approximation.pi (Approximation.sin (Algebra.add Approximation.one Approximation.pi))) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Algebra.mul (Algebra.div Approximation.three (Algebra.mul (Algebra.mul (Algebra.mul (Algebra.add Approximation.three (Approximation.sin (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.sinh (Algebra.div Approximation.e Approximation.e))) (Approximation.mpow (Algebra.mul Approximation.three (Approximation.sinh (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.sinh (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Algebra.add (Approximation.msqrt (Approximation.exp (Algebra.sub (Approximation.exp (Approximation.sin (Approximation.exp (Approximation.to_base i)))) (Algebra.sub (Approximation.cos (Approximation.cos (Approximation.cos (Approximation.sin (Approximation.cos (Approximation.to_base i)))))) Approximation.three)))) (Algebra.add (Approximation.cos (Approximation.cos (Algebra.add (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))) (Approximation.exp (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))))))) Approximation.pi)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 14 (graph 20 20 20 20)
100.000%

Elapsed Time: 367 sec
Graph (size = 18)
Generation: 17
Best individual: 9247681.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.one Approximation.one) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.e Approximation.e Approximation.e) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.two Approximation.pi (Approximation.sin (Algebra.add Approximation.one Approximation.pi))) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Algebra.mul (Algebra.div Approximation.three (Algebra.mul (Algebra.mul (Algebra.mul (Algebra.add Approximation.three (Approximation.sin (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.sinh (Algebra.div Approximation.e Approximation.e))) (Approximation.mpow (Algebra.mul Approximation.three (Approximation.sinh (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.sinh (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Algebra.add (Approximation.msqrt (Approximation.exp (Algebra.sub (Approximation.exp (Approximation.sin (Approximation.exp (Approximation.to_base i)))) (Algebra.sub (Approximation.cos (Approximation.cos (Approximation.cos (Approximation.sin (Approximation.cos (Approximation.to_base i)))))) Approximation.three)))) (Algebra.add (Approximation.cos (Approximation.cos (Algebra.add (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))) (Approximation.exp (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))))))) Approximation.pi)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 14 (graph 20 20 20 20)
100.000%

Elapsed Time: 535 sec
Graph (size = 18)
Generation: 18
Best individual: 9247681.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.one Approximation.one) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.e Approximation.e Approximation.e) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.two Approximation.pi (Approximation.sin (Algebra.add Approximation.one Approximation.pi))) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Algebra.mul (Algebra.div Approximation.three (Algebra.mul (Algebra.mul (Algebra.mul (Algebra.add Approximation.three (Approximation.sin (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.sinh (Algebra.div Approximation.e Approximation.e))) (Approximation.mpow (Algebra.mul Approximation.three (Approximation.sinh (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.sinh (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Algebra.add (Approximation.msqrt (Approximation.exp (Algebra.sub (Approximation.exp (Approximation.sin (Approximation.exp (Approximation.to_base i)))) (Algebra.sub (Approximation.cos (Approximation.cos (Approximation.cos (Approximation.sin (Approximation.cos (Approximation.to_base i)))))) Approximation.three)))) (Algebra.add (Approximation.cos (Approximation.cos (Algebra.add (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))) (Approximation.exp (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))))))) Approximation.pi)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 14 (graph 20 20 20 20)
100.000%

Elapsed Time: 624 sec
Graph (size = 18)
Generation: 19
Best individual: 9247681.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.one Approximation.one) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.e Approximation.e Approximation.e) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.two Approximation.pi (Approximation.sin (Algebra.add Approximation.one Approximation.pi))) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Algebra.mul (Algebra.div Approximation.three (Algebra.mul (Algebra.mul (Algebra.mul (Algebra.add Approximation.three (Approximation.sin (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.sinh (Algebra.div Approximation.e Approximation.e))) (Approximation.mpow (Algebra.mul Approximation.three (Approximation.sinh (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.sinh (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Algebra.add (Approximation.msqrt (Approximation.exp (Algebra.sub (Approximation.exp (Approximation.sin (Approximation.exp (Approximation.to_base i)))) (Algebra.sub (Approximation.cos (Approximation.cos (Approximation.cos (Approximation.sin (Approximation.cos (Approximation.to_base i)))))) Approximation.three)))) (Algebra.add (Approximation.cos (Approximation.cos (Algebra.add (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))) (Approximation.exp (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))))))) Approximation.pi)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 14 (graph 20 20 20 20)
100.000%

Elapsed Time: 814 sec
Graph (size = 18)
Generation: 20
Best individual: 9253764.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.one Approximation.one) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.e Approximation.two Approximation.two) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.zero Approximation.zero Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Algebra.mul (Algebra.div Approximation.three (Algebra.mul (Algebra.mul (Algebra.mul (Algebra.add Approximation.three (Approximation.sin (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.sinh (Algebra.div Approximation.e Approximation.e))) (Approximation.mpow (Algebra.mul Approximation.three (Approximation.sinh (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.sinh (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.mpow (Approximation.mpow (Algebra.div Approximation.three (Approximation.cosh (Approximation.to_base i))) (Approximation.msqrt (Algebra.sub Approximation.three (Algebra.add (Algebra.sub (Algebra.div Approximation.three (Approximation.cos (Approximation.to_base i))) (Approximation.cos (Approximation.mpow (Approximation.mpow Approximation.three (Approximation.cosh (Approximation.to_base i))) (Approximation.cosh (Approximation.to_base i))))) (Approximation.to_base i))))) (Approximation.msqrt (Approximation.mpow (Approximation.mpow (Approximation.mpow Approximation.zero (Approximation.mpow (Algebra.mul Approximation.three (Approximation.mpow (Approximation.mpow (Algebra.div Approximation.one (Algebra.mul (Algebra.mul (Algebra.mul (Approximation.mpow Approximation.one (Approximation.cosh (Approximation.to_base i))) (Approximation.mpow (Algebra.div (Algebra.mul Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.div (Algebra.mul Approximation.three (Algebra.div (Algebra.div (Algebra.div (Algebra.div Approximation.three (Approximation.cos (Approximation.to_base i))) (Approximation.cosh (Approximation.to_base i))) (Approximation.cosh (Approximation.to_base i))) (Algebra.div (Algebra.div Approximation.three (Approximation.cosh (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Approximation.cos (Approximation.to_base i))) (Approximation.cos (Approximation.to_base i))) (Algebra.mul (Algebra.div Approximation.e (Algebra.div (Algebra.div (Algebra.div (Algebra.div Approximation.two (Approximation.msqrt (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i))) (Algebra.div (Algebra.div (Algebra.div (Algebra.sub Approximation.three (Approximation.cos (Approximation.to_base i))) (Approximation.cos (Approximation.to_base i))) (Approximation.cos (Approximation.to_base i))) (Algebra.mul (Algebra.div Approximation.two (Approximation.cos (Approximation.to_base i))) (Approximation.to_base i))))) (Approximation.exp (Approximation.to_base i))) (Algebra.mul (Algebra.div (Algebra.div (Approximation.mpow Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Algebra.mul (Algebra.mul (Approximation.mpow Approximation.three (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i))))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Approximation.mpow Approximation.zero (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.sin (Approximation.mpow (Approximation.cosh (Approximation.cosh (Approximation.cosh Approximation.zero))) (Approximation.cos (Approximation.to_base i)))))) (Algebra.div Approximation.e (Algebra.add Approximation.zero (Approximation.cosh (Approximation.mpow (Algebra.mul Approximation.two (Approximation.mpow (Approximation.mpow (Algebra.mul (Approximation.mpow Approximation.three (Algebra.mul (Algebra.mul (Algebra.mul (Algebra.div Approximation.three (Approximation.sin (Approximation.to_base i))) (Algebra.sub (Algebra.mul Approximation.two (Algebra.sub (Algebra.sub (Algebra.sub (Algebra.div Approximation.two (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Algebra.add (Algebra.sub Approximation.two (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Algebra.add (Algebra.mul Approximation.zero (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Algebra.div (Approximation.mpow Approximation.zero (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i))))))) (Approximation.exp (Approximation.to_base i))))), Approximation.mpow (Approximation.cosh (Approximation.log (Algebra.add (Approximation.msqrt (Approximation.exp (Algebra.sub (Approximation.exp (Approximation.sin (Approximation.exp (Approximation.to_base i)))) (Algebra.sub (Approximation.cos (Approximation.cos (Approximation.cos (Approximation.sin (Approximation.cos (Approximation.to_base i)))))) Approximation.three)))) (Algebra.add (Approximation.cos (Approximation.cos (Algebra.add (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))) (Approximation.exp (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))))))) Approximation.pi)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 14 (graph 20 20 20 20)
100.000%

Elapsed Time: 1172 sec
Graph (size = 18)
Generation: 21
Best individual: 9253764.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.one Approximation.one) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.e Approximation.two Approximation.two) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.zero Approximation.zero Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Algebra.mul (Algebra.div Approximation.three (Algebra.mul (Algebra.mul (Algebra.mul (Algebra.add Approximation.three (Approximation.sin (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.sinh (Algebra.div Approximation.e Approximation.e))) (Approximation.mpow (Algebra.mul Approximation.three (Approximation.sinh (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.sinh (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.mpow (Approximation.mpow (Algebra.div Approximation.three (Approximation.cosh (Approximation.to_base i))) (Approximation.msqrt (Algebra.sub Approximation.three (Algebra.add (Algebra.sub (Algebra.div Approximation.three (Approximation.cos (Approximation.to_base i))) (Approximation.cos (Approximation.mpow (Approximation.mpow Approximation.three (Approximation.cosh (Approximation.to_base i))) (Approximation.cosh (Approximation.to_base i))))) (Approximation.to_base i))))) (Approximation.msqrt (Approximation.mpow (Approximation.mpow (Approximation.mpow Approximation.zero (Approximation.mpow (Algebra.mul Approximation.three (Approximation.mpow (Approximation.mpow (Algebra.div Approximation.one (Algebra.mul (Algebra.mul (Algebra.mul (Approximation.mpow Approximation.one (Approximation.cosh (Approximation.to_base i))) (Approximation.mpow (Algebra.div (Algebra.mul Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.div (Algebra.mul Approximation.three (Algebra.div (Algebra.div (Algebra.div (Algebra.div Approximation.three (Approximation.cos (Approximation.to_base i))) (Approximation.cosh (Approximation.to_base i))) (Approximation.cosh (Approximation.to_base i))) (Algebra.div (Algebra.div Approximation.three (Approximation.cosh (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Approximation.cos (Approximation.to_base i))) (Approximation.cos (Approximation.to_base i))) (Algebra.mul (Algebra.div Approximation.e (Algebra.div (Algebra.div (Algebra.div (Algebra.div Approximation.two (Approximation.msqrt (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i))) (Algebra.div (Algebra.div (Algebra.div (Algebra.sub Approximation.three (Approximation.cos (Approximation.to_base i))) (Approximation.cos (Approximation.to_base i))) (Approximation.cos (Approximation.to_base i))) (Algebra.mul (Algebra.div Approximation.two (Approximation.cos (Approximation.to_base i))) (Approximation.to_base i))))) (Approximation.exp (Approximation.to_base i))) (Algebra.mul (Algebra.div (Algebra.div (Approximation.mpow Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Algebra.mul (Algebra.mul (Approximation.mpow Approximation.three (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i))))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Approximation.mpow Approximation.zero (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.sin (Approximation.mpow (Approximation.cosh (Approximation.cosh (Approximation.cosh Approximation.zero))) (Approximation.cos (Approximation.to_base i)))))) (Algebra.div Approximation.e (Algebra.add Approximation.zero (Approximation.cosh (Approximation.mpow (Algebra.mul Approximation.two (Approximation.mpow (Approximation.mpow (Algebra.mul (Approximation.mpow Approximation.three (Algebra.mul (Algebra.mul (Algebra.mul (Algebra.div Approximation.three (Approximation.sin (Approximation.to_base i))) (Algebra.sub (Algebra.mul Approximation.two (Algebra.sub (Algebra.sub (Algebra.sub (Algebra.div Approximation.two (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Algebra.add (Algebra.sub Approximation.two (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Algebra.add (Algebra.mul Approximation.zero (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Algebra.div (Approximation.mpow Approximation.zero (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i))))))) (Approximation.exp (Approximation.to_base i))))), Approximation.mpow (Approximation.cosh (Approximation.log (Algebra.add (Approximation.msqrt (Approximation.exp (Algebra.sub (Approximation.exp (Approximation.sin (Approximation.exp (Approximation.to_base i)))) (Algebra.sub (Approximation.cos (Approximation.cos (Approximation.cos (Approximation.sin (Approximation.cos (Approximation.to_base i)))))) Approximation.three)))) (Algebra.add (Approximation.cos (Approximation.cos (Algebra.add (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))) (Approximation.exp (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))))))) Approximation.pi)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 14 (graph 20 20 20 20)
100.000%

Elapsed Time: 1556 sec
Graph (size = 18)
Generation: 22
Best individual: 9253764.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.one Approximation.one) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.e Approximation.two Approximation.two) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.zero Approximation.zero Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Algebra.mul (Algebra.div Approximation.three (Algebra.mul (Algebra.mul (Algebra.mul (Algebra.add Approximation.three (Approximation.sin (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.sinh (Algebra.div Approximation.e Approximation.e))) (Approximation.mpow (Algebra.mul Approximation.three (Approximation.sinh (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.sinh (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.mpow (Approximation.mpow (Algebra.div Approximation.three (Approximation.cosh (Approximation.to_base i))) (Approximation.msqrt (Algebra.sub Approximation.three (Algebra.add (Algebra.sub (Algebra.div Approximation.three (Approximation.cos (Approximation.to_base i))) (Approximation.cos (Approximation.mpow (Approximation.mpow Approximation.three (Approximation.cosh (Approximation.to_base i))) (Approximation.cosh (Approximation.to_base i))))) (Approximation.to_base i))))) (Approximation.msqrt (Approximation.mpow (Approximation.mpow (Approximation.mpow Approximation.zero (Approximation.mpow (Algebra.mul Approximation.three (Approximation.mpow (Approximation.mpow (Algebra.div Approximation.one (Algebra.mul (Algebra.mul (Algebra.mul (Approximation.mpow Approximation.one (Approximation.cosh (Approximation.to_base i))) (Approximation.mpow (Algebra.div (Algebra.mul Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.div (Algebra.mul Approximation.three (Algebra.div (Algebra.div (Algebra.div (Algebra.div Approximation.three (Approximation.cos (Approximation.to_base i))) (Approximation.cosh (Approximation.to_base i))) (Approximation.cosh (Approximation.to_base i))) (Algebra.div (Algebra.div Approximation.three (Approximation.cosh (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Approximation.cos (Approximation.to_base i))) (Approximation.cos (Approximation.to_base i))) (Algebra.mul (Algebra.div Approximation.e (Algebra.div (Algebra.div (Algebra.div (Algebra.div Approximation.two (Approximation.msqrt (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i))) (Algebra.div (Algebra.div (Algebra.div (Algebra.sub Approximation.three (Approximation.cos (Approximation.to_base i))) (Approximation.cos (Approximation.to_base i))) (Approximation.cos (Approximation.to_base i))) (Algebra.mul (Algebra.div Approximation.two (Approximation.cos (Approximation.to_base i))) (Approximation.to_base i))))) (Approximation.exp (Approximation.to_base i))) (Algebra.mul (Algebra.div (Algebra.div (Approximation.mpow Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Algebra.mul (Algebra.mul (Approximation.mpow Approximation.three (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i))))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Approximation.mpow Approximation.zero (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.sin (Approximation.mpow (Approximation.cosh (Approximation.cosh (Approximation.cosh Approximation.zero))) (Approximation.cos (Approximation.to_base i)))))) (Algebra.div Approximation.e (Algebra.add Approximation.zero (Approximation.cosh (Approximation.mpow (Algebra.mul Approximation.two (Approximation.mpow (Approximation.mpow (Algebra.mul (Approximation.mpow Approximation.three (Algebra.mul (Algebra.mul (Algebra.mul (Algebra.div Approximation.three (Approximation.sin (Approximation.to_base i))) (Algebra.sub (Algebra.mul Approximation.two (Algebra.sub (Algebra.sub (Algebra.sub (Algebra.div Approximation.two (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Algebra.add (Algebra.sub Approximation.two (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Algebra.add (Algebra.mul Approximation.zero (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Approximation.exp (Approximation.to_base i))) (Algebra.div (Approximation.mpow Approximation.zero (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i))))))) (Approximation.exp (Approximation.to_base i))))), Approximation.mpow (Approximation.cosh (Approximation.log (Algebra.add (Approximation.msqrt (Approximation.exp (Algebra.sub (Approximation.exp (Approximation.sin (Approximation.exp (Approximation.to_base i)))) (Algebra.sub (Approximation.cos (Approximation.cos (Approximation.cos (Approximation.sin (Approximation.cos (Approximation.to_base i)))))) Approximation.three)))) (Algebra.add (Approximation.cos (Approximation.cos (Algebra.add (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))) (Approximation.exp (Approximation.log (Approximation.exp (Approximation.log (Approximation.to_base i)))))))) Approximation.pi)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 14 (graph 20 20 20 20)
100.000%

Elapsed Time: 1815 sec
Graph (size = 18)
Generation: 23
Best individual: 9272025.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.one Approximation.one) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.three Approximation.one) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.zero (Approximation.cos Approximation.zero) Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Algebra.mul (Algebra.div Approximation.three (Algebra.mul (Algebra.mul (Algebra.mul (Algebra.add Approximation.three (Approximation.sin (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.sinh (Algebra.div Approximation.e Approximation.e))) (Approximation.mpow (Algebra.mul Approximation.three (Approximation.sinh (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.sinh (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Algebra.add (Approximation.msqrt (Approximation.exp (Algebra.sub (Approximation.exp (Approximation.sin (Approximation.exp (Approximation.to_base i)))) (Algebra.sub (Approximation.cos (Approximation.cos (Approximation.cos (Approximation.sin (Approximation.cos (Approximation.to_base i)))))) Approximation.three)))) (Algebra.add (Approximation.cos (Approximation.cos (Approximation.mpow (Approximation.cos (Approximation.cosh (Approximation.cos (Approximation.to_base i)))) (Approximation.mpow (Approximation.msqrt (Approximation.msqrt (Approximation.log (Approximation.cosh (Approximation.log (Approximation.to_base i)))))) Approximation.two)))) Approximation.pi)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 14 (graph 20 20 20 20)
100.000%

Elapsed Time: 2644 sec
Graph (size = 18)
Generation: 24
Best individual: 9272025.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.one Approximation.one) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.three Approximation.one) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.zero (Approximation.cos Approximation.zero) Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Algebra.mul (Algebra.div Approximation.three (Algebra.mul (Algebra.mul (Algebra.mul (Algebra.add Approximation.three (Approximation.sin (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.sinh (Algebra.div Approximation.e Approximation.e))) (Approximation.mpow (Algebra.mul Approximation.three (Approximation.sinh (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.sinh (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Algebra.add (Approximation.msqrt (Approximation.exp (Algebra.sub (Approximation.exp (Approximation.sin (Approximation.exp (Approximation.to_base i)))) (Algebra.sub (Approximation.cos (Approximation.cos (Approximation.cos (Approximation.sin (Approximation.cos (Approximation.to_base i)))))) Approximation.three)))) (Algebra.add (Approximation.cos (Approximation.cos (Approximation.mpow (Approximation.cos (Approximation.cosh (Approximation.cos (Approximation.to_base i)))) (Approximation.mpow (Approximation.msqrt (Approximation.msqrt (Approximation.log (Approximation.cosh (Approximation.log (Approximation.to_base i)))))) Approximation.two)))) Approximation.pi)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 14 (graph 20 20 20 20)
100.000%

Elapsed Time: 3580 sec
Graph (size = 18)
Generation: 25
Best individual: 9272025.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.one Approximation.one) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.three Approximation.one) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.zero (Approximation.cos Approximation.zero) Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Algebra.mul (Algebra.div Approximation.three (Algebra.mul (Algebra.mul (Algebra.mul (Algebra.add Approximation.three (Approximation.sin (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.sinh (Algebra.div Approximation.e Approximation.e))) (Approximation.mpow (Algebra.mul Approximation.three (Approximation.sinh (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.sinh (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Algebra.add (Approximation.msqrt (Approximation.exp (Algebra.sub (Approximation.exp (Approximation.sin (Approximation.exp (Approximation.to_base i)))) (Algebra.sub (Approximation.cos (Approximation.cos (Approximation.cos (Approximation.sin (Approximation.cos (Approximation.to_base i)))))) Approximation.three)))) (Algebra.add (Approximation.cos (Approximation.cos (Approximation.mpow (Approximation.cos (Approximation.cosh (Approximation.cos (Approximation.to_base i)))) (Approximation.mpow (Approximation.msqrt (Approximation.msqrt (Approximation.log (Approximation.cosh (Approximation.log (Approximation.to_base i)))))) Approximation.two)))) Approximation.pi)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 14 (graph 20 20 20 20)
100.000%

Elapsed Time: 4527 sec
Graph (size = 18)
Generation: 26
Best individual: 9272025.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.one Approximation.one) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.three Approximation.one) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.zero (Approximation.cos Approximation.zero) Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Algebra.mul (Algebra.div Approximation.three (Algebra.mul (Algebra.mul (Algebra.mul (Algebra.add Approximation.three (Approximation.sin (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.sinh (Algebra.div Approximation.e Approximation.e))) (Approximation.mpow (Algebra.mul Approximation.three (Approximation.sinh (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.sinh (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Algebra.add (Approximation.msqrt (Approximation.exp (Algebra.sub (Approximation.exp (Approximation.sin (Approximation.exp (Approximation.to_base i)))) (Algebra.sub (Approximation.cos (Approximation.cos (Approximation.cos (Approximation.sin (Approximation.cos (Approximation.to_base i)))))) Approximation.three)))) (Algebra.add (Approximation.cos (Approximation.cos (Approximation.mpow (Approximation.cos (Approximation.cosh (Approximation.cos (Approximation.to_base i)))) (Approximation.mpow (Approximation.msqrt (Approximation.msqrt (Approximation.log (Approximation.cosh (Approximation.log (Approximation.to_base i)))))) Approximation.two)))) Approximation.pi)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 14 (graph 20 20 20 20)
100.000%

Elapsed Time: 8757 sec
Graph (size = 18)
Generation: 27
Best individual: 9272025.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.one Approximation.one) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.three Approximation.one) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.zero (Approximation.cos Approximation.zero) Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Algebra.mul (Algebra.div Approximation.three (Algebra.mul (Algebra.mul (Algebra.mul (Algebra.add Approximation.three (Approximation.sin (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.sinh (Algebra.div Approximation.e Approximation.e))) (Approximation.mpow (Algebra.mul Approximation.three (Approximation.sinh (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.sinh (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Algebra.add (Approximation.msqrt (Approximation.exp (Algebra.sub (Approximation.exp (Approximation.sin (Approximation.exp (Approximation.to_base i)))) (Algebra.sub (Approximation.cos (Approximation.cos (Approximation.cos (Approximation.sin (Approximation.cos (Approximation.to_base i)))))) Approximation.three)))) (Algebra.add (Approximation.cos (Approximation.cos (Approximation.mpow (Approximation.cos (Approximation.cosh (Approximation.cos (Approximation.to_base i)))) (Approximation.mpow (Approximation.msqrt (Approximation.msqrt (Approximation.log (Approximation.cosh (Approximation.log (Approximation.to_base i)))))) Approximation.two)))) Approximation.pi)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 14 (graph 20 20 20 20)
100.000%

Elapsed Time: 55013 sec
Graph (size = 18)
Generation: 28
Best individual: 9272025.000000
Unquoted: let rec x = fun ax ay az agraph n -> if ax <= 0 then new vector3D() else (if n <= 0 then V(Approximation.one, Approximation.zero, Approximation.zero) else Algebra.mk_vector3D Approximation.two Approximation.one Approximation.one) and y = fun ax ay az agraph n -> if ay <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.one, Approximation.zero) else Algebra.mk_vector3D Approximation.one Approximation.three Approximation.one) and z = fun ax ay az agraph n -> if az <= 0 then new vector3D() else (if n <= 0 then V(Approximation.zero, Approximation.zero, Approximation.one) else Algebra.mk_vector3D Approximation.zero (Approximation.cos Approximation.zero) Approximation.zero) and graph = fun ax ay az agraph n -> if agraph <= 0 then new option<PlanarGraph>() else ([1..n] |> fun list -> List.map (fun i -> (Algebra.div (Algebra.sub Approximation.two (Algebra.div (Algebra.div (Algebra.div (Algebra.add Approximation.two (Approximation.cos (Approximation.to_base i))) (Algebra.mul (Algebra.div Approximation.three (Algebra.mul (Algebra.mul (Algebra.mul (Algebra.add Approximation.three (Approximation.sin (Approximation.to_base i))) (Approximation.sinh (Approximation.to_base i))) (Approximation.sinh (Algebra.div Approximation.e Approximation.e))) (Approximation.mpow (Algebra.mul Approximation.three (Approximation.sinh (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.sinh (Approximation.to_base i)))) (Approximation.exp (Approximation.to_base i))) (Approximation.mpow (Algebra.div Approximation.one (Approximation.exp (Approximation.to_base i))) (Approximation.to_base i)))) (Approximation.msqrt (Approximation.to_base i)), Approximation.mpow (Approximation.cosh (Approximation.log (Algebra.add (Approximation.msqrt (Approximation.exp (Algebra.sub (Approximation.exp (Approximation.sin (Approximation.exp (Approximation.to_base i)))) (Algebra.sub (Approximation.cos (Approximation.cos (Approximation.cos (Approximation.sin (Approximation.cos (Approximation.to_base i)))))) Approximation.three)))) (Algebra.add (Approximation.cos (Approximation.cos (Approximation.mpow (Approximation.cos (Approximation.cosh (Approximation.cos (Approximation.to_base i)))) (Approximation.mpow (Approximation.msqrt (Approximation.msqrt (Approximation.log (Approximation.cosh (Approximation.log (Approximation.to_base i)))))) Approximation.two)))) Approximation.pi)))) (Approximation.mpow (Approximation.exp (Approximation.exp (Approximation.msqrt (Approximation.log (Approximation.msqrt (Approximation.to_base i)))))) Approximation.one))) list |> fun list -> List.fold (fun graph tupledArg -> Graph.add_vertex graph (let t1,_ = tupledArg in t1) (let _,t2 = tupledArg in t2)) Some(Graph.empty_graph) list) in fun () -> Program.fitness 14 (graph 20 20 20 20)
80.816%^C
Omars-Mac-Pro:RCN omarmrivas$ ls
Algebra.fs       bin              pool14.save      pool5.save
Approximation.fs obj              pool15.save      pool6.save
DataTypes.fs     pool10.save      pool16.save      pool7.save
Graph.fs         pool11.save      pool17.save      pool8.save
Program.fs       pool12.save      pool18.save      pool9.save
RCN.fsproj       pool13.save      pool4.save
Omars-Mac-Pro:RCN omarmrivas$ 
